# 多变量图 {#cha:gallery3}

> 　　福尔摩斯小心地打开字条，在腿上摊平，用放大镜仔细查看，不漏掉一个微小细节。
>
> 　　“从纸质看，是印度当地生产的纸张，以前被钉在板子上。”他说，“纸上画的是大房子的局部建筑图，有许多厅房、走廊和过道。图上有个小红叉，上方用铅笔写着‘左3.37’，字迹模糊不清。左角有个奇怪的象形文字，像四个十字架连成一排，旁边写着‘四签名—— 乔纳森·斯莫尔、穆罕默德·辛格、阿卜杜拉·克安、多斯特·阿克巴’，字迹粗糙潦草。坦白说，我也看不出字条和你的案子有什么关系，但肯定是重要资料。字条两面都干净光洁，想必一直保存在皮夹里。”
>
> ——柯南 $\cdot$ 道尔《四签名》

本章介绍展示三个或三个以上变量关系的统计图形。其中，比较常见的是散点图矩阵、条件分割图、三维透视图和地图。其它不常见的图形也略作介绍。此外，矩阵和二维联表在形式上是二维结构，但实际上有三个变量，理应归入本章。但是，考虑到矩阵和联表的特殊形式，我们将在第\@ref(cha:gallerymatrix)章再集中介绍。


## 散点图矩阵 {#sec:scatterplot-matrix}

### 概述 {-}

散点图矩阵（Scatterplot Matrices）是散点图的高维扩展。它的基本构成是普通散点图（\@ref(sec:plot-default) 小节），只是将多个变量的两两散点图以矩阵的形式排列起来，就构成了所谓的散点图矩阵，通常包含 $p\times p$ 个窗格（$p$ 为变量个数）。散点图矩阵从一定程度上克服了在平面上展示高维数据的困难，对于我们查看变量之间的两两关系非常有用。

### 示例 {-}

图 \@ref(fig:pairs)
是对鸢尾花数据（表 \@ref(tab:tab-iris)）所作的散点图矩阵。除了展示任意两个变量之间的关系外。对角线窗格显示的是直方图，从中我们可以看到四个变量各自的分布情况。上三角窗格中用不同样式的点标记出了鸢尾花的不同类型（参考图 \@ref(fig:point-iris)
）；下三角窗格中简化了点的样式，但是 添加了一条平滑曲线，对鸢尾花的四个变量两两之间的关系作出了一种非参数概括（散点图平滑技术，参见 @Cleveland79）。

(ref:fig-pairs-s) 鸢尾花数据的散点图矩阵

(ref:fig-pairs) 鸢尾花数据的散点图矩阵：上三角区域为不同样式的点，对应着不同种类的鸢尾花，对角线的直方图展示了花瓣花萼长宽的一维分布，下三角区域用平滑曲线显示了变量之间的关系

```{r pairs,fig.width=4.8,fig.height=4.8,fig.cap="(ref:fig-pairs)",fig.scap="(ref:fig-pairs-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("pairs")
```

### 绘制方法 {-}

R 语言绘制散点图矩阵的基础函数为 `pairs()` ，其用法如下：

```{r pairs-usage, results='asis'}
usage2(usage(pairs.default, output = FALSE))
usage2(usage(graphics:::pairs.formula, output = FALSE))
```

散点图矩阵函数是泛型函数，可以直接接受数据矩阵或者公式作为参数。 

\noindent 参数含义：

`x`:
: 一个矩阵或数据框，包含了要作散点图的那些变量。

`labels`:
: 变量名称（标签）。

`panel`:
: 给定一个画散点图的函数，这个函数将应用在每一格图形中。有时候我们并不需要统一的散点图函数，这时可以利用 `lower.panel` 和 `upper.panel` 来分别指定上三角窗格和下三角窗格中的作图函数，也就意味着上三角和下三角窗格中的图形（不一定非得是散点图）可以不一样； `diag.panel` 和 `text.panel` 分别指定对角线窗格上的作图函数和添加文本标签的函数。

`label.pos`:
: 指定文本标签的位置。

`cex.labels`:
: 指定标签的缩放倍数。

`font.labels`:
: 指定标签的字体样式。

`row1attop`:
: 逻辑值，指定散点图的第 1 行出现在顶部还是底部（按常规讲，前者是矩阵的形式，后者是图的形式，因为矩阵通常是从上至下、从左至右，而图的坐标是从下至上、从左至右）。

`gap`:
: 设定窗格之间的间距大小。

图 \@ref(fig:pairs) 的绘制代码如下（注意其中的上三角和下三角作图函数是如何定义的）：

```{r, results='asis'}
msg_code("pairs")
```

**ggplot2** 包所支持的 **GGally** 包给散点图矩阵里添加了更为复杂的信息，下面是一个代码示例。你能看懂该段代码绘制的图 \@ref(fig:fig-ggally) 吗？

```{r, results='asis'}
msg_code("pairs2")
```

(ref:fig-pairs2-s) 鸢尾花数据的散点图矩阵增强版

(ref:fig-pairs2) 鸢尾花数据的散点图矩阵增强版：散点图、直方图、密度曲线图、箱线图的结合

```{r fig-ggally, fig.height=10, fig.width=10, fig.cap="(ref:fig-pairs2)", fig.scap="(ref:fig-pairs2-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("pairs2")
```

在变量数目较多时，我们不妨将散点图矩阵作为一种探索变量之间相关关系的工具，它比起相关系数矩阵等统计指标来优势在于：散点图矩阵展示了所有原始数据，这样我们可以看到变量之间的任何关系（线性或非线性、离群点），从而避免被单一的统计指标所误导。

## 条件分割图 {#sec:coplot}

### 概述 {-}

条件分割图（Conditioning Plot）的思想源自于统计学中的条件分布，即：给定某一个（或几个）变量之后看我们所关心的变量的分布情况。在条件分割图中，这种"分布"主要指的是两个变量之间的关系，通常以散点图表示。

条件分割图可以看作是对散点图的进一步深入发掘，它可以以一个或者两个条件变量作为所有数据的划分条件，条件变量在图形的边缘用灰色矩形条标记出变量的取值范围，每个矩形条对应着一幅散点图（严格来说此时应该称作"条件散点图"），这就是条件分割图的基本做法。

### 示例 {-}

一组斐济岛（Fiji）附近的地震数据包括了地震发生地点的经纬度和震源的深度（表 \@ref(tab:tab-quakes)）。我们想知道该地区在地震深度上分布是否均匀。因此，我们令深度变量为条件变量，绘制了图 \@ref(fig:coplot)，看看在不同条件下地震发生地点（经纬度）是否有变化。

```{r tab-quakes}
data(quakes)
kable2(quakes, "斐济岛附近的地震数据")
```

(ref:fig-coplot-s) 给定震源深度范围的地震经纬度条件分割图

(ref:fig-coplot) 给定震源深度范围的地震经纬度条件分割图：四幅散点图有相同的坐标系，震源深度按左下、右下、左上、右上的顺序逐渐增加，可以看到地震发生地点逐渐在向斐济岛靠近

```{r coplot,fig.width=4.8,fig.height=4.8, fig.cap="(ref:fig-coplot)", fig.scap="(ref:fig-coplot-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("coplot")
```

从图中可以清楚看出，随着深度值的增加，地震发生地点逐渐由西向东、由南向北移动，震源较深的地震都发生在离斐济岛很近的东南侧。

### 绘制方法 {-}

R 中条件分割图的函数为 `coplot()`，其用法如下：

```{r coplot-usage, results='asis'}
usage2(usage(coplot, output = FALSE))
usage2(usage(co.intervals, output = FALSE))

```
\noindent 参数含义：
 
`formula`:
: 一个公式，形式为 `y ~ x | a`（一个条件变量）或 `y ~ x | a * b`（两个条件变量），"`|`" 后面即为条件变量。

`data`:
: 数据，其中包含了 `x` 、 `y` 、 `a` 和 `b` 等变量。

`given.values`: 
: 指定条件变量的取值范围。

`panel`:
: 该函数的关键参数，它决定了每一幅散点图的画法，默认只是画点，我们可以将其任意扩展为我们需要的图示功能，如添加回归直线等等。

`rows` 和 `columns`:
: 设定散点图的摆放行数和列数。

`col` 和 `pch`:
: 分别设定散点图中点的颜色和样式。

`bar.bg`:
: 给定条件变量指示条的填充颜色。

`number` 和 `overlap`:
: 传给 `co.intervals()` 函数，用来计算划分连续变量的区间，前者设定划分段数，后者设定区间之间的重叠比例，如：

```{r co-intervals-demo, echo=TRUE}
co.intervals(1:10, number = 5, overlap = 0.5)
```

\noindent 上述代码将数字 `1:10` 划分为了 5 段，每段长度为 2，重叠长度为 1，因此重叠比例为 0.5。条件分割图中散点图的顺序是从左到右、从下到上，分别与条件变量从左到右、从下到上的指示条对应。

图 \@ref(fig:coplot) 的绘制代码为：

```{r, results='asis'}
msg_code("coplot")
```

这个例子展示了 `panel` 参数的用法。我们借助 **maps** 包 [@maps] 在散点图上添加了新西兰和斐济岛的地图作为辅助信息。关于 R 中地图的使用请参考 \@ref(sec:maps) 小节。

## 符号图 {#sec:symbols}

### 概述 {-}

符号图是用各种符号展示高维数据的图示工具，它的主要思想是将高维数值体现在图形中符号的特征上。因为受到平面的限制，我们对于高维数据的展示方法总是很有限，仅仅是对于二维数据的展示最为方便，对更高维度的如三维、四维甚至五维的数据相对缺乏好的工具。由于符号的存在，使得我们可以将高于二维的数据"寄托"在符号的各种特征上，如：以矩形为散点图的基本符号，那么我们可以用其长宽分别代表两个变量，这样一幅图形中至少可以放置四个变量；类似地，我们可以以圆圈、正方形、多边形、箱线图、温度计等符号为散点图中的"点"，于是散点图就可以被扩展为高维数据的展示工具。

### 示例 {-}

我们以《中国统计年鉴》里我国 31 省市自治区的人口特征数据为例，通过实际数据来看符号图在展示数据时的效果。表 \@ref(tab:ChinaPop-data) 显示了我国 2005 年人口自然增长率、年底人口总数、城镇人口比重、人口预期寿命和高学历人数五个变量。我们以此作为国民素质的刻画指标，绘制了图 \@ref(fig:symbols-pop) [@Xie08]。

```{r ChinaPop-data}
source(system.file("extdata", "ChinaPop.R", package = "MSG"), encoding = "UTF-8")
kable2(as.data.frame(ChinaPop), "我国 31 省市自治区的人口特征数据")
```


(ref:fig-symbols-pop-s) 中国 31 地区五大国民素质特征分布温度计图

(ref:fig-symbols-pop) 2005 年中国 31 地区五大国民素质特征分布温度计图

```{r symbols-pop,fig.width=6,fig.height=6,out.width="80%",results="hide",fig.cap="(ref:fig-symbols-pop)",fig.scap="(ref:fig-symbols-pop-s)"}
demo("ChinaPop", package = "MSG")
```

这幅图融合了多种图形和图形元素。它的基础是一幅等高图（参见 \@ref(sec:contour) 小节和图 \@ref(fig:contour-pop)），利用人口预期寿命和高学历人数两个变量计算二维密度，画出等高线，便完成了底图的制作。然后，我们通过人口预期寿命和高学历人数两个变量的数值往图中添加温度计符号，温度计宽代表增长率，高代表总人口数，温度代表城镇人口比重。接着，我们将各省市的文本标签添加到图中。

经过这些图形元素的表达，全国 31 省市自治区的五项人口特征便一目了然，例如，通过温度计的高度可以观察出三个人口大省广东、山东、河南（相应的人口总量小的地区如西藏、青海、宁夏等也容易看出），由宽度可以看出西藏、青海、宁夏、新疆等省市自治区的人口自然增长率非常高（而北京、上海、天津等直辖市的增长率则很低）。从温度指示的情况来看，北京、上海和天津三大直辖市的城镇人口比例要远高于其它地区；从整幅散点图来看，人口平均预期寿命与高学历者人数呈比较明显的正相关关系。箱线图和坐标轴须分别刻画了人口平均预期寿命与高学历者人数各自的分布特征。这样，我们就完成了在平面上描述五维变量的任务。

从这幅图，我们可以看出掌握基本图形元素使用的用处和重要性——没有一种统计软件能够提供现成的模块或函数来完成类似的任务。

### 绘制方法 {-}

R 中的符号图函数为 `symbols()`，它提供了六种基本符号：圆、正方形、长方形、星形、温度计和箱线图，分别由相应的参数指定； `symbols()` 的用法如下：

```{r symbols-usage, results='asis'}
usage2(usage(symbols, output = FALSE))
```

如前所述，符号图的基础是散点图，因此首先要给出两个参数 `x` 和 `y` 以便作散点图，然后在散点的位置上画出符号。接下来的六个参数分别指定符号的形状。图 \@ref(fig:symbols)
给出了六种基本符号的形状，注意观察各种符号是如何利用自己的特征将高维数据表达出来的。

(ref:fig-symbols-s) 符号图提供的六种基本符号

(ref:fig-symbols) 符号图提供的六种基本符号

```{r symbols,fig.width=6,fig.height=6,fig.cap="(ref:fig-symbols)",fig.scap="(ref:fig-symbols-s)", dev='tikz', fig.showtext = FALSE}
demo("symbols_all", echo = FALSE, package = "MSG")
```

\noindent 参数含义：

`circles`
:   圆：一个数值向量，给定圆的半径（实际上是与圆的半径成比例，下同）。

`squares`
:   正方形：一个数值向量，给定正方形的边长。

`rectangles`
:   长方形：一个矩阵，列数为 2，这两列分别给定长方形的宽和高。

`stars`
:   星形：一个矩阵，列数 $\geq3$，类似雷达图，给定从星星中心向每个方向的射线的长度（严格说是线段），最终这些射线的端点会连接起来形成一个星形，但射线本身不会被画出来；缺失值将被视作 0 （星形在符号图中并不直观，推荐直接使用星状图，见 \@ref(fig:stars) 小节）。

`thermometers`
:   温度计：一个矩阵，列数为 3 或 4，前两列分别给定温度计的宽和高；若矩阵为三列，那么第三列为温度计内的"温度"高度，注意这一列的值应该小于 1，否则温度的填充会超过温度计的范围；若矩阵为四列，那么温度将按照第三列与第四列的比率进行填充，同样，这两列的比率需要小于 1。

`boxplots`
:   箱线图：一个矩阵，列数为 5。前两列分别给定箱子的宽和高；第三、四列分别给定两条线（下线和上线）的长度；第五列与温度计类似，给定箱线图内的中位数标记线在箱子内部的高度比例，因此这一列数据也需要在 $[0,1]$ 范围内。这里只是借用了箱线图的称谓，符号图中的箱线与真正的箱线图之间没有关系。

不难看出，这六种符号图能展示的数据维度分别为 3、3、4、$\geq5$、5 或 6、7。

`inches`
: 逻辑值，控制着符号的大小。若为 `TRUE`（默认），那么图中所有符号的最长长度（边长或半径等等）将被设置为 1 英寸（约 2.54 厘米），其它长度按比例缩放；若该参数取一个正数，那么类似地，所有符号的最长长度的英寸值为该正数，因此 `TRUE` 和 1 的效果是相同的；如果为 `FALSE`，那么符号的长度单位取相应坐标轴的单位，例如符号中的 1 长度即为坐标轴上的 1 单位。

`add`
: 逻辑值，设定是否将符号图添加到现有图形上。

`fg`
: 符号的前景色。

`bg`
: 符号的背景色或填充色。

其它参数用来添加标题、设定坐标轴范围等。

利用该函数，可以绘制图 \@ref(fig:symbols-pop)。读者可以运行以下函数来获取代码：

```{r, eval=FALSE, echo=TRUE}
demo("ChinaPop", package = "MSG")
```


## 星状图、蛛网图、雷达图 {#sec:stars}

### 概述 {-}

星状图（Star Plot）、蛛网图（Spider Plot）和雷达图（Radar Plot）本质上是一类图形，它们都用线段离中心的长度来表示变量值的大小。这三种图形名称的区别在于：星状图用来展示很多个多变量个体，各个个体的图形相互独立，从而整幅图形看起来就像很多星星；蛛网图和雷达图将多个多变量个体放在同一张图形上，看起来就像是蛛网或雷达的形状，这样重叠的图形就称为蛛网图或者雷达图。简单说来，就是星状图有若干个中心，而蛛网图和雷达图只有一个中心。

### 示例 {-}

1974 年，*Motor Trend* 杂志给出了一组汽车数据（表 \@ref(tab:mtcars-data)），记录了 7 个变量：`mpg` 为每加仑汽油可行驶英里数，`cyl` 为汽缸数，`disp` 为汽缸排量，`hp` 为马力，`drat` 为背齿轮比，`wt` 为车重，`qsec` 为行驶 $1/4$ 英里的时间。

(ref:tab-mtcars) 1974 年 Motor Trend 杂志的一组汽车数据

(ref:tab-mtcars-s) 1974 年 *Motor Trend* 杂志的一组汽车数据

```{r mtcars-data}
data(mtcars)
kable2(mtcars[, 1:7], "(ref:tab-mtcars)", x_scap2 = "(ref:tab-mtcars-s)")
```

我们为这组数据绘制了图 \@ref(fig:stars) 所示的星状图。从图中可以看到各种品牌和型号的汽车在这七方面的指标和性能表现。以星状图展示数据可以让我们很快找到一些有突出特征的个体，从而省去了在大批数据中逐个寻找、排序的过程。

(ref:fig-stars-s) *Motor Trend* 杂志 1974 年汽车数据的星状图

(ref:fig-stars) Motor Trend 杂志 1974 年汽车数据的星状图

```{r stars,fig.width=5,fig.height=4.8,fig.cap="(ref:fig-stars)",fig.scap="(ref:fig-stars-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("stars")
```

### 绘制方法 {-}

R 中星状图的函数为 `stars()` ，其用法如下：

```{r stars-usage, warning=FALSE, results='asis'}
# usage2(usage(stars, output = FALSE))
```

```{r, eval=FALSE, echo=TRUE}
stars(x, full = TRUE, scale = TRUE, radius = TRUE, 
    labels = dimnames(x)[[1L]], locations = NULL, nrow = NULL,
    ncol = NULL, len = 1, key.loc = NULL, 
    key.labels = dimnames(x)[[2L]], key.xpd = TRUE, xlim = NULL,
    ylim = NULL, flip.labels = NULL, draw.segments = FALSE, 
    col.segments = 1L:n.seg, col.stars = NA, col.lines = NA, 
    axes = FALSE, frame.plot = axes, main = NULL, sub = NULL, 
    xlab = "", ylab = "", cex = 0.8, lwd = 0.25, lty = par("lty"), 
    xpd = FALSE,
    mar = pmin(
      par("mar"), 
      1.1 + c(2 * axes + (xlab != ""), 2 * axes + (ylab !=""), 1, 0)), 
    add = FALSE, plot = TRUE, ...)
```

\noindent 参数含义：

`x`:
: 一个多维数据矩阵或数据框，每一行数据将生成一个星形。

`full`:
: 逻辑值，决定了是否使用整圆（或半圆）。

`scale`:
: 决定是否将数据标准化到区间 $[0,1]$ 内。

`radius`:
: 决定是否画出半径。

`labels`:
: 为每个个体的名称，默认为数据的行名

`locations`:
: 以一个两列的矩形给出每个星形的放置位置，默认放在一个规则的矩形网格上。若提供给该参数一个长度为 2 的向量，那么所有的星形都将被放在该坐标上，从而形成蛛网图或雷达图。

`nrow` 和 `ncol`:
: 分别给定网格的行数和列数以便摆放星形，默认 `nrow` 等于 `ncol`。

`len`:
: 半径和线段的缩放倍数。

`key.loc`:
: 提供比例尺的坐标位置。

`key.labels`:
: 比例尺的标签，默认为变量名称。

`key.xpd`:
: 设定比例尺的作图范围，参见 \@ref(sec:par) 小节（`par("xpd")`）。

`flip.labels`:
: 设定每个星形底部的名称是否互相上下错位，以免名称太长导致文本之间互相重叠。

`draw.segments`:
: 设定是否作线段图，即每个变量以一个扇形表示。

`col.segments`:
: 设定每个扇形区域的颜色（当 `draw.segments` 为 `FALSE` 时无效）。

`col.stars`:
: 设定每个星形的颜色（当 `draw.segments` 为 `TRUE` 时无效）。

`axes`:
: 决定是否画坐标轴。

`frame.plot`:
: 决定是否画整个图形的边框。

`add`:
: 决定是否将图形添加到当前图形上。

下面是绘制汽车数据星状图的代码示例：

```{r, results='asis'}
msg_code("stars")
```

## 脸谱图 {#sec:faces}

### 概述 {-}

人的脸部（确切来说是头部）有很多特征，例如眼睛大小、眉毛弧度、脸宽、鼻高等。这些特征都可以用数值大小来测量。于是，@Chernoff73 提出了脸谱图，将一批数值对应到这些脸部特征上来，如数据的第一列控制眼睛大小、第二列控制嘴巴大小等,每一行观测数据都可以像这样画出一个人脸来。由于人眼通常很容易辨别这些脸谱的具体特征（如谁的脸胖、谁笑得最夸张），因此脸谱图能很好反映其背后的数值大小。这种方式展示多元数据非常形象有趣。

### 示例 {-}

我们对汽车数据（表 \@ref(tab:mtcars-data)）绘制了脸谱图，如图 \@ref(fig:faces2)，通过脸部特征展示了 5 个变量，分别为马力 `hp`、气缸排量 `disp`、每加仑行驶英里数 `mpg`、行驶 1/4 英里时间 `qsec` 和车重 `wt`，指定这几个变量分别用眼睛大小、嘴宽、眼距、鼻长和下半脸宽来表示。

(ref:fig-faces2-s) 部分汽车数据的脸谱图

(ref:fig-faces2) 部分汽车数据的脸谱图：谁的脸宽？谁的鼻子长？谁的眼睛大？

```{r faces2,fig.width=5.8,fig.height=6.2,fig.cap="(ref:fig-faces2)",fig.scap="(ref:fig-faces2-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("faces2")
```

这幅汽车脸谱图的解读方式是：眼睛瞪得越大，说明该车型的马力越大；嘴越宽则气缸排量越大；两眼距离越大则越省油（每加仑汽油跑得越远）；鼻子越长则说明跑得越快；脸越宽则说明车越重。那么，我们很容易看出，Maserati Bora 马力最强（大眼睛），Lincoln Continental 等车气缸排量较大（宽嘴），Honda Civic 等车比较省油（眼距大），Merc 230 跑得最快（鼻子长），Lincoln Continental 等车最重（脸胖）。


### 绘制方法 {-}

R 语言的 **TeachingDemos** 包 [@TeachingDemos] 提供了两个脸谱图函数 `faces()` 和 `faces2()` 。两个函数能反映的面部特征不尽相同，各有所长，例如 `faces()` 可以画头发和耳朵，但 `faces2()` 可以画更多的变量。这里我们只介绍后者，读者可以阅读前者的帮助文档了解更多信息。

`faces2()` 的用法如下：

```{r faces2-usage, warning=FALSE, results='asis'}
# library(TeachingDemos)
# usage2(usage(faces2, output = FALSE))
```

```{r, eval=FALSE, echo=TRUE}
faces2(mat, which = 1:ncol(mat), labels = rownames(mat), 
    nrows = ceiling(nrow(mat)/ncols), 
    ncols = ceiling(sqrt(nrow(mat))), byrow = TRUE, 
    scale = c("columns", "all", "center", "none"),
    fill = c(0.5, 0.5, 1,   0.5, 0.5, 0.3, 0.5, 0.5, 0.5, 
             0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1,   0.5), ...)
```

\noindent 参数含义：

`mat`:
: 主要参数，是一个数据矩阵，每一行对应着一张脸谱，脸谱中各个部位的特征对应着矩阵中的列。

`which`:
: 一个重要参数，用来指定数据矩阵中的每一列分别对应着何种面部特征，是一个整数向量，向量的每个元素取值在 1 到 18 之间，分别表示：

- 1 额头和脸之间的横线宽度（一张脸谱上半部分为额头，下半部分为脸）
- 2 额头和脸的相对高度（取值越大则额头越矮脸越高）
- 3 脸高
- 4 上半边脸的宽度
- 5 下半边脸的宽度
- 6 鼻子长度
- 7 嘴巴高度
- 8 嘴巴弧度（绝对值应小于 9）
- 9 嘴巴宽度
- 10 眼睛高度
- 11 两只眼睛之间的距离（取值 0.5\~0.9）
- 12 眼睛和眉毛的弧度
- 13 眼睛圆圈的形状（取值越大越呈椭圆形，越小越圆）
- 14 眼睛大小
- 15 眼珠和眉毛的位置（越大越靠左，越小越靠右）
- 16 眉毛高度
- 17 眉毛弧度
- 18 眉毛宽度

这些不同取值结合后面的例子就更容易理解了。

`nrows` 和 `ncols`:
: 决定按多少行列排列这些脸谱，默认尽量以方形 $n\times n$ 的样式排版。

`scale`:
: 决定如何标准化数据，默认对列标准化使之取值在 $[0, 1]$ 上；若数据不足 18 列，那么 `fill` 参数中的值就会补充不足的列的取值。

...:
: 传给 `text()` 函数，往图中加标签（默认是行名）。

下面的代码可以绘制汽车数据的脸谱图：

```{r, results='asis'}
msg_code("faces2")
```

这里，我们设置参数 `which = c(14, 9, 11, 6, 5)`，是为了尽量将这几个汽车性能指标形象化到合适的脸部特征上（如瞪着大眼睛表示马力大）。读者在遇到具体的案例数据时，不妨也仔细考虑一下指标的实际意义以及安排它们到哪个面部表情上。很多人都知道宏基施振荣的"微笑曲线"并且对之印象深刻，其原因何尝不是因为这条曲线形象而且直观呢？

在众多统计图形中，脸谱图可算是最有幽默味道的一种，读者不妨在一些轻松的场合或听众精力不集中时尝试使用这种图形，也许能让听众感觉眼前一亮，主动解读图中的数据。

## 三元图 {#subsec:ternary}

### 概述 {-}

三元图（Ternary diagram）是用来展示一类特殊数据的图形：数据只有三列，每一行之和为 1 或 100，这类数据通常是成分数据，在化学中比较常见，比如某混合物中各种成分的百分比。又如，我们知道土壤可以分为沙土（`sand`）、壤土（`clay`）和黏土（`silt`）三种成分或类别，从不同地点采集的土壤样本在这三种成分上的分布可能不一样。

### 示例 {-}

表 \@ref(tab:murcia-data) 展示了西班牙 Murcia 省土壤样本成分的部分数据。这批数据包含 88 个样本，取自 8 个样地，每个样地随机取 11 处样本。我们关心的问题是，用这些成分数据能否区分出不同的样地？

```{r murcia-data}
data(murcia, package = "MSG")
kable2(murcia, "西班牙 Murcia 省土壤样本成分")
```

(ref:murcia-ternary) 西班牙 Murcia 省的土壤样本三元图：三角形的三个顶点分别代表沙土、壤土和黏土。图中的点越靠近某个顶点则说明该成分越大

(ref:murcia-ternary-s) 西班牙 Murcia 省的土壤样本三元图

```{r murcia-ternary,fig.cap="(ref:murcia-ternary)",fig.scap="(ref:murcia-ternary-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("murcia-ternary")
```

图 \@ref(fig:murcia-ternary) 是这批数据的三元图。三元图的思想是把每一行数据以一个点的形式放在等边三角形中，它越靠近三角形的某个顶点则说明对应的成分数值越大。显然，如果一个点完全处在某个顶点上，那么说明这个点对应的样本在某个成分上取值为 100%，在另外两个成分上取值为 0%。图 \@ref(fig:murcia-ternary) 中 8 个样地分别用不同颜色标记，可以看出，每个样地的三种成分有所区别，比如左下角的一批样本（绿点）的沙土成分较大，而右上角的样本（蓝点）沙土成分很小。

### 绘制方法 {-}

本案例的三元图是用 **vcd** 包中的 `ternaryplot()` 函数所作的。数据加载和三元图绘制的 R 代码如下：

```{r, results='asis'}
msg_code("murcia-ternary")
```

由于数据中的成分数值差异不是太极端，所以图中的点都聚在一起，不太容易观察。感兴趣的读者可以自行编写函数实现设置坐标轴范围的功能，例如本例的图可以通过缩小坐标轴范围来放大点与点之间的差异。

实际上，这个图形的核心计算部分非常简单：假设原始数据是 $(a,\,b,\,c)$ 且 $a+b+c=1$，那么在三元图中的坐标就是 $(b+c/2,\,\sqrt{3}c/2)$。也就是说，三元图本质上就是散点图。这个坐标变换的原理是物理学中的质心概念：首先我们知道等边三角形三个顶点的坐标分别为 $(0,\,0)$，$(1,\,0)$ 和 $(1/2,\,\sqrt{3}/2)$，如果以一条数据的三个成分为权重对这三个顶点坐标加权平均的话，得到的就是该条数据对应的坐标，实际上也就是认为三个顶点上的质量都为 1，以成分为权重求质心的位置，即 $(0a+1b+c/2,\,0a+0b+\sqrt{3}c/2)$。

## 马赛克图 {#sec:mosaicplot}

### 概述 {-}

马赛克图（Mosaic Plots）是展示多维列联表数据的工具。我们在 \@ref(sec:assocplot) 和 \@ref(sec:fourfoldplot) 小节介绍了两种展示列联表数据的工具，但它们都只能展示低维列联表，而马赛克图对于列联表的维数没有限制。

马赛克图的表现形式为与频数成比例的矩形块，整幅图形看起来就像是若干块马赛克放置在平面上。马赛克图背后的统计理论是对数线性模型（log-linear model），我们先回顾一个最简单的二维列联表的独立模型。

二维列联表的独立性从概率角度来说就是单元格的频率等于边际频率的乘积：

\begin{equation}
\pi_{ij}=\pi_{i\cdot}\pi_{\cdot j}
(\#eq:independence)
\end{equation}

取对数即得：

\begin{equation}
\mathrm{log}(\pi_{ij})=\mathrm{log}(\pi_{i\cdot})+\mathrm{log}(\pi_{\cdot j})
(\#eq:logindependence)
\end{equation}

根据 $\mu_{ij}=n\pi_{ij}$ 进一步写成频数的形式：

\begin{equation}
\mathrm{log}(\mu_{ij})=\lambda+\lambda_{i}^{r}+\lambda_{j}^{c}
(\#eq:freqindependence)
\end{equation}

$\lambda_{i}^{r}$ 和 $\lambda_{j}^{c}$ 分别表示行效应和列效应，$\lambda$ 为常数。 \@ref(eq:freqindependence) 式就是最普通的对数线性模型。通过计算拟合，我们可以得到行列效应的估计值。对数线性模型在马赛克图中的主要表现是单元格的残差，而单元格的残差可以有三种：似然比残差（离差，deviance）$G^{2}$、Pearson $\chi^{2}$ 残差和 Freeman-Tukey 残差，前两种定义如下式：

\begin{equation}
G^{2}=2\sum n_{ij}\mathrm{log}(\frac{n_{ij}}{\hat{\mu}_{ij}});\;\;\chi^{2}=\sum\frac{\left(n_{ij}-\hat{\mu}_{ij}\right)^{2}}{\hat{\mu}_{ij}}
(\#eq:loglinearres)
\end{equation}

残差反映的是某个单元格拟合的好坏。马赛克图用 5 级颜色表达了残差的大小，后面我们结合具体例子说明。

### 示例 {-}

泰坦尼克号沉船事件是人类历史上最著名的海难之一，至今仍然有很多人在研究它。这场灾难中乘客生还情况的原始数据见表 \@ref(tab:Titanic-data)。该数据给出了分舱位（一二三等舱和船员舱）、分性别（男女）、分年龄（大人小孩）的生存情况。我们所关心的问题主要是通过一些比例看出当时救援的侧重性，如：是否头等舱的乘客生还比例最高？"女士和孩子优先" 的原则在各船舱有没有被很好遵守？

```{r Titanic-data}
data(Titanic)
kable2(as.data.frame(ftable(Titanic)), "泰坦尼克号乘客生还情况", only_head = FALSE)
```

(ref:fig-mosaicplot-s) 泰坦尼克号乘客生还数据马赛克图

(ref:fig-mosaicplot) 泰坦尼克号乘客生还数据马赛克图：按性别、年龄和船舱等级划分

```{r mosaicplot,fig=T,fig.width=5.2,fig.height=5,fig.cap="(ref:fig-mosaicplot)",fig.scap="(ref:fig-mosaicplot-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("mosaicplot")
```

图 \@ref(fig:mosaicplot) 以马赛克图的形式将这个 $4\times2\times2\times2$ 的列联表数据展示在了同一张图中。通过矩形块（马赛克）的大小，我们可以清楚看出各舱位、不同性别、年龄的人群的生还状况。

例如，对头等舱来说，无论是大人小孩或男女，下方的矩形都比上方的矩形要高（尤其是女性和小孩），这说明头等舱的生还率相对来说都比较高，很可能当时的救援是偏向头等舱的。从年龄来说，头等舱和二等舱中小孩的生存率要远高于大人，但三等舱中小孩的生存率和大人相比差异并不是太显著；但从性别角度来看，各舱位基本上还是将生存机会优先让给女性了，男性的生还率在各舱位来说都相对较低。

类似地，我们还可以从图中挖掘出更多的现象，这里不再深入。另外，图中用不同颜色表示各单元格的残差大小，其中虚线框表示残差为负数，我们可以清楚看出哪些单元格的拟合欠佳。

### 绘制方法 {-}

R 中马赛克图的函数为 `mosaicplot()` ，其用法如下：

```{r mosaicplot-usage, results='asis'}
usage2(usage(graphics:::mosaicplot.default, output = FALSE))
usage2(usage(graphics:::mosaicplot.formula, output = FALSE))
```

马赛克图函数是泛型函数，可以直接接受列联表数据或者公式作为参数，这里我们只介绍前一种情况。

\noindent 参数含义：

`x`:
: 一个列联表数据（可以用函数 `table()` 生成）。

`main` 、 `sub` 、 `xlab` 和 `ylab`:
: 分别设定主标题、副标题和坐标轴标题。

`sort`:
: 指定展示变量的顺序。

`dir`:
: 指定马赛克图的拆分方向（横向拆分或纵向拆分）。

`type`:
: 给定残差的类型，即如前所述的三种残差。

下面的代码可以绘制泰坦尼克号生还数据的马赛克图：

```{r, results='asis'}
msg_code("mosaicplot")
```

感兴趣的读者还可以使用 **stats** 包中的 `loglin()` 函数拟合对数线性模型、从统计模型的角度继续分析。


## 因素效应图 {#plot-design}

### 概述 {-}

方差分析是很常见的统计模型，其目的是比较不同组别之间的因变量均值是否有显著差异。因素效应图所展现的就是各种分组条件下因变量的水平，这里的水平可以由任何统计函数定义，例如均值、中位数等。

### 示例 {-}

我们以经纱断裂数据 `warpbreaks` 为例，这个数据包含三个变量：经纱断裂数目 `breaks` 、羊毛种类 `wool`（A、B 两种）和拉力强度 `tension`（L、M、H 三种强度），如表 \@ref(tab:tab-warpbreaks) 所示。
我们可以通过因素效应图（图 \@ref(fig:plot-design)）看羊毛种类和拉力强度两个变量分别对经纱断裂根数的影响。

```{r tab-warpbreaks}
data(warpbreaks)
kable2(warpbreaks, "经纱断裂数据")
```

(ref:fig-plot-design-s) 经纱断裂数据的因素效应图

(ref:fig-plot-design) 经纱断裂数据的因素效应图：每种羊毛（A、B）和拉力强度（L、M、H）下断裂数目的均值（上图）和中位数（下图）

```{r plot-design,fig.width=4.8,fig.height=5,fig.cap="(ref:fig-plot-design)",fig.scap="(ref:fig-plot-design-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("plot-design")
```

上图中的刻度线展示出了不同羊毛种类和拉力强度下断裂根数的均值，下图展示的是中位数，两幅图有一定差异，说明数据的分布不对称（中位数和均值不相等）。

### 绘制方法 {-}

R 中因素效应图的函数为 `plot.design()`，其用法如下：

```{r plot-design-usage, results='asis'}
usage2(usage(plot.design, output = FALSE))
```

\noindent 参数含义：

`x`:
: 包含自变量（分类变量）的数据框，它也可以包含因变量，这种情况下第二个参数就不必提供了。

`y`:
: 因变量。

`fun`:
: 计算因变量水平的函数。

`data`:
: 所用数据，包含自变量和因变量。当参数 `x` 为一个公式时，则会用到本参数提取数值，否则不必提供本参数。

其它参数用于调整图形外观或设置图形标题、标记等。

图 \@ref(fig:plot-design) 的绘制代码如下：

```{r, results='asis'}
msg_code("plot-design")
```

我们也可以通过方差分析模型查看这两种因素的影响：

```{r warpbreaks-aov, echo=TRUE}
summary(aov(breaks ~ wool + tension, data = warpbreaks))
```

从以上结果中可以看出，拉力强度对经纱断裂根数有显著影响，而羊毛种类则不太显著。

总地来说，因素效应图是一种非常初级的统计图形，在数据的探索性分析中可能会起到一定作用。有时我们完全可以用一些分类汇总函数去计算各因素的效应（各组均值），例如分别按羊毛种类和拉力强度计算断裂数目的均值：

```{r warpbreaks-mean, echo=TRUE}
with(warpbreaks, tapply(breaks, wool, mean))
with(warpbreaks, tapply(breaks, tension, mean))
```

## 交互效应图

### 概述 {-}

在回归模型或方差分析中，我们常遇到交互效应的概念。

所谓交互效应，就是一个自变量对因变量的影响大小受另一个变量取值水平的影响，以二元回归为例，以下就是一个典型的含有交互效应的回归模型：

$$y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+\beta_{12}x_{1}x_{2}+\epsilon$$

令 $c_{2}\equiv\beta_{2}+\beta_{12}x_{1}$，上式可以改写为：

$$\begin{aligned}
y & =  \beta_{0}+\beta_{1}x_{1}+(\beta_{2}+\beta_{12}x_{1})x_{2}+\epsilon\\
 & \equiv  \beta_{0}+\beta_{1}x_{1}+c_{2}x_{2}+\epsilon\end{aligned}$$

显然，变量 $x_{2}$ 对因变量 $y$ 的影响系数 $c_{2}$ 受 $x_{1}$ 取值水平的控制，同理 $x_{1}$ 对  $y$ 的影响也受 $x_{2}$ 取值水平的影响。若模型中不存在交互项 $x_{1}x_{2}$，那么无论 $x_{1}$ 取值水平如何，$x_{2}$ 每增加 1 单位，$y$ 都会变化 $\beta_{2}$ 单位，对 $x_{2}$ 而言同理。

以上数学原理用更直白的话来说就是，若因变量随一个变量的变化幅度与另一个变量的取值水平无关，那么模型中不存在交互效应。这个现象反映到图中，便有了交互效应图。

交互效应图通常是针对分类变量而言，看一个分类变量给定分类水平时，因变量在另一个分类变量各水平下的均值如何变化。这种变化趋势如果在前一个分类变量换一个取值水平后仍然保持相同的话，则说明这两个分类变量没有交互效应。

### 示例 {-}

一批法国食道癌数据记录了一组人群的年龄、饮酒量、抽烟量以及是否患食道癌（表 \@ref(tab:tab-esoph)）。前三个变量都是以分组形式记录的分类变量。我们不难想象，年龄越高则患食道癌的可能性就会越大，但我们现在关心的问题是，在不同饮酒量水平下，年龄对食道癌的影响是一致的吗？

```{r tab-esoph}
data(esoph)
kable2(esoph, "法国食道癌数据")
```

(ref:fig-interaction-plot-s) 法国食道癌数据的交互效应图

(ref:fig-interaction-plot) 法国食道癌数据的交互效应图：各饮酒组的折线走势大致一样，说明交互作用很微弱

```{r interaction-plot,fig.width=6.5,fig.height=4,fig.cap="(ref:fig-interaction-plot)",fig.scap="(ref:fig-interaction-plot-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("interaction-plot")
```

图 \@ref(fig:interaction-plot) 是我们为此绘制的交互效应图。该图对问题的回答大致是肯定的，因为图中各条折线的增长趋势是差不多的。也就是说，不管人群属于哪种饮酒量水平，年龄对患食道癌概率的影响关系都大致一样。但是，其中也有一些微小的差异。例如年龄组从 35-44 岁 到 45-54 岁，患食道癌的概率在饮酒量大于 40 克/天的人群中会增长大约 20 %；但饮酒量小于 40 克/天的人群中，患食道癌的概率反而略微有所下降，在这里我们可以看到一点交互总用。但总体来说，各饮酒组中，年龄对食道癌的影响方向还是大体一致的。

### 绘制方法 {-}

R 中交互效应图的函数为 `interaction.plot()`，用法如下：

```{r interaction-plot-usage, results='asis'}
usage2(usage(interaction.plot, output = FALSE))
```

\noindent 参数含义：

`x.factor`:
: 横坐标上的分类变量.

`trace.factor`：
: 第二个分类变量，按照这个分类变量的不同取值水平将 `x.factor` 分类下的因变量均值连接起来。

`response`:
: 因变量。

`fun`:
: 指定的对因变量汇总的函数，默认为均值，当然我们也可以指定其它计算函数，如中位数 `median()`。

`type`:
: 画图类型，见 \@ref(sec:plot) 小节图 \@ref(fig:plot-type)。

`legend`:
: 决定是否画图例。

其它参数用以设置图形细节，如各条均值连线的线条样式等。

图 \@ref(fig:interaction-plot) 的绘制代码如下：

```{r, results='asis'}
msg_code("interaction-plot")
```

图中显示的那种似有似无的交互作用可以用方差分析来检验：

```{r, echo=TRUE}
with(esoph, {
  # 方差分析，交互项系数不显著
  summary(aov(ncases / (ncases + ncontrols) ~ agegp * alcgp))
})
```

交互项的 P 值大于 0.05，
说明交互项基本上可以忽略（系数不显著）。总之，从交互效应图看两个分类变量是否有交互作用，只需要看各条折线是否大致平行即可。

我们也可以计算一下每种分组组合下的因变量均值，辅助理解图 \@ref(fig:interaction-plot)：

```{r esoph-mean, echo=TRUE}
tbl = aggregate(ncases / (ncases + ncontrols) ~ agegp * alcgp, 
                 data = esoph, mean)
colnames(tbl) = c("agegp", "alcgp", "mean")
reshape(tbl, timevar = "alcgp", idvar = "agegp", 
        direction = "wide", sep = "_")
```

## 分类与回归树图 {#sec:rpart}

### 概述 {-}

分类与回归树（Classification and Regression Tree，CART）是一种递归分割（Recursive Partition）技术，目的是寻找自变量的某种分割，使得样本分割之后因变量各组之间的差异最大。这种分割会一直递归进行下去，直到满足停止条件。详细理论请参见 @Breiman84。

### 示例 {-}

一组脊椎矫正手术数据如表 \@ref(tab:tab-kyphosis) 所示，包含了一个因变量 `Kyphosis`（术后是否还存在脊椎畸形）和三个自变量 `Age`（年龄，以月计）、`Number`（畸形脊椎的数目）和 `Start`（从上往下数第一段畸形脊椎的位置）。我们希望知道这三个自变量对脊椎矫正手术结果的影响，例如怎样特征的小孩手术容易失败。

```{r tab-kyphosis}
data(kyphosis, package = "rpart")
kable2(kyphosis, "脊椎矫正手术数据")
```

我们作了一棵简单的分类树，如图 \@ref(fig:rpart)。该数据
分类与回归树的读法为：每个节点上的条件若满足则树枝向左生长，否则向右生长，每片叶子（最底端，即不再生长枝节的地方）上标明了该处的因变量的预测结果[^rpart-plot]，下方也给出了该叶节点上样本的因变量构成情况。

[^rpart-plot]: 若因变量为分类变量，则预测值按照多数投票表决（majority vote）原则计算；若为数值变量，则按照叶节点上的样本均值预测。

(ref:fig-rpart-s) 脊椎矫正手术结果的分类树图

(ref:fig-rpart) 脊椎矫正手术结果的分类树图

```{r rpart,fig.width=6,fig.height=4,out.width="80%", fig.cap="(ref:fig-rpart)",fig.scap="(ref:fig-rpart-s)"}
msg_graph("rpart")
```

从图 \@ref(fig:rpart) 中可以看出：`Start` 小于 8.5 的小孩的矫正手术容易失败（右边叶节点上有 11 例失败和 8 例成功）；对于 `Start` 大于或等于 8.5 的小孩来说，手术结果需要继续按照自变量拆分；`Start` 大于或等于 14.5 的 29 名小孩中，所有小孩的手术均获成功，这表明手术成败的重要因素是小孩的第一段畸形脊椎的位置——这个位置越靠下，则手术越易成功；若前面的条件不满足，则继续向右拆分。下一个拆分变量为年龄；从下面的几个叶节点来看，年龄越大则手术越不容易成功。

### 绘制方法 {-}

**rpart** 包 [@rpart] 提供了分类与回归树的计算拟合函数 `rpart()` ，同时扩充了泛型函数 `plot()` ——凡是 `rpart` 类型的对象在作图时都会自动调用 `plot.rpart()` 生成树图。`plot.rpart()` 的用法如下：

```{r plot-rpart-usage, results='asis'}
library(rpart)
usage2(usage(rpart:::plot.rpart, output = FALSE))
```

\noindent 参数含义：

`x`:
: 一个 rpart 类型的对象，一般由 `rpart()` 函数拟合产生。

`uniform`:
: 决定是否在从上至下的枝节点之间使用相等的纵向距离，以避免树枝在某些局部区域靠得太近而使图形难以辨认。默认情况下，每两个枝节点之间的距离与拟合误差成比例。

`branch`:
: 设定树枝的形状。`0` 为 "V" 字型，`1` 为垂直的形状。该参数可以取 $[0,1]$ 之间的数值，以使得数值形状更像 "V" 或更垂直。

`compress`:
: 设定是否在横向上压缩树枝的间距使得图形更紧凑。

图 \@ref(fig:rpart) 的绘制代码如下：

```{r, results='asis'}
msg_code("rpart")
```

在该图的基础上，我们还可以将叶节点的信息进一步扩充展示。例如，对于连续型因变量，我们可以将每个叶节点上的样本因变量分布用箱线图或直方图或任何其它展示密度的工具在另一幅图上对应表达出来；对于离散型因变量，则可以利用条形图等工具将样本因变量的频数表达出来。图形的布局可以利用 `layout()` 函数（\@ref(sec:multipage) 小节）等一页多图的方法来实现。关于这样的例子，读者可以参考 @Everitt06 或 @Xie07 等。

## 平行坐标图 {#sec:parcoords}

### 概述 {-}

平行坐标 [@Inselberg07] 是对通常的笛卡尔坐标思维的替代。

我们知道，笛卡尔坐标系通常情况下最多只能容纳两个变量（横轴 $x$，纵轴 $y$），所以在这样的坐标系下无法直接画出多个变量。当然，前面提到了很多变通方法，使得多元数据可以在笛卡尔坐标系下被表达出来，如 \@ref(sec:symbols) 小节的符号图。

平行坐标系的基本做法是将相互垂直的坐标轴改成平行的坐标轴。由于平面上可以容纳很多平行线，所以平行坐标系中可以放置多个变量。在每根坐标轴上，根据变量数值大小描点，如数值越大则点的位置越高，而对于一行观测数据，由于它有多列，每一列都相应对应着一根平行线上的点，最终我们把这些点用折线连起来，也就形成了构成平行坐标图的基本元素。类似地，多行数据就能描绘出多条折线。平行坐标图就是由这些折线加上相应的平行坐标轴构成的。

### 示例 {-}

图 \@ref(fig:ggparcoord) 是鸢尾花数据（表 \@ref(tab:tab-iris)）的平行坐标图，数据经过了默认的标准化，取值都在 $[0,1]$ 区间上；其中每条折线代表一朵花。

(ref:fig-ggparcoord-s) 鸢尾花数据的平行坐标图

(ref:fig-ggparcoord) 鸢尾花数据的平行坐标图：花萼长宽和花瓣长宽以及花的种类

```{r ggparcoord,fig.width=4.8,fig.height=2.5,fig.cap="(ref:fig-ggparcoord)",fig.scap="(ref:fig-ggparcoord-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("ggparcoord")
```

从图中我们可以看出，setosa 这种花的花瓣较小，而另外两种花的花瓣都较大；但 setosa 的花萼特别宽；versicolor 这种花总体来说和 virginica 比较像，只是相对来说尺寸小一些。

另外，从图中我们也可以看出相邻变量之间的正向或负向相关关系。例如，由于花萼宽（Sepal.Width）和花瓣长（Petal.Length）两个变量间的线段有很多相交，说明这两个变量有负相关关系；而对于 setosa 这类花来说，由于花萼长和花萼宽这两个变量之间的线段都朝向相同的方向，因此这两个变量在 setosa 这类花中有正向相关关系。

为什么平行坐标图中线段相交则意味着负相关、平行则意味着正相关呢？我们退回到平行坐标图的作法就很容易理解了：如果线段大量相交，那么说明第一个变量的大值对应着第二个变量的小值，反之亦然。此消彼长，此起彼伏，当然就是负相关了；正相关同理。

此外，由于平行坐标图画出了多个变量，有时候我们可以借助图中折线的位置来观察聚类现象。若图 \@ref(fig:ggparcoord)
中没有加以颜色标注，读者应该能感觉出所有的数据至少可以分为两类（setosa 和其它），因为花瓣形状小的那些花很可能是单独的一类花，对应着图中偏下的那一簇折线。后面调和曲线图（\@ref(sec:andrews-curve) 小节）与平行坐标图有着相似的外观，它更能体现这里的聚类思想。

### 绘制方法 {-}

在 R 中有很多包都可以画平行坐标图，例如 **GGally** 包 [@GGally] 中的 `ggparcoord()` 函数、**MASS** 包 [@Venables02] 中的 `parcoord()` 函数和 **iplots** 包 [@iplots] 中的 `ipcp()` 函数等。

`ggparcoord()` 函数的用法如下：

```{r ggparcoord-usage, results='asis'}
library(GGally)
usage2(usage(ggparcoord, output = FALSE))
```

\noindent 参数含义：

`data`:
: 一个数据框，含有多列变量。

`columns`:
: 要参与画图的列，这个列的顺序也决定了每根平行坐标轴的摆放顺序。

`scale`:
: 指定标准化数据的方法，可以将列标准化到 $[0, 1]$ 区间上（默认），也可以标准化为均值为 0、方差为 1 的向量，或者不进行标准化。

图 \@ref(fig:ggparcoord) 的绘制代码如下：

```{r, results='asis'}
msg_code("ggparcoord")
```

上文我们从图中得到的结论可以用数值方式验证：

```{r iris-cor}
# 第 2、3 列的相关系数（花萼宽和花瓣长）
cor(iris[, 2:3])
# 第 1、2 列在 setosa 下的相关系数（先对数据取子集）
cor(subset(iris, Species == "setosa", 1:2))
```

需要提醒读者注意的是，平行坐标图中的变量顺序非常重要，它直接影响了图的外观，也限制了我们对数据的观察，尤其是相关关系，因为从平行坐标图中我们只可能观察相邻变量之间的关系。有时候将变量顺序交换一下，则也许可以观察到新的信息。

## 调和曲线图 {#sec:andrews-curve}

### 概述 {-}

调和曲线图由 @Andrews72 提出，它是一种巧妙展示多元数据的技术。我们先介绍一下它的数学原理，然后再说明它为何巧妙。

对于一个数据矩阵 $X_{n\times p}$，我们把其中每一行 $X_{i}=\left(X_{i,1},\ldots,X_{i,p}\right)$ 转化为一条曲线：

\begin{equation}
f_{i}(t)=\begin{cases}
\frac{X_{i,1}}{\sqrt{2}}+X_{i,2}\sin(t)+X_{i,3}\cos(t)+\cdots\\
\qquad+X_{i,p-1}\sin(\frac{p-1}{2}t)+X_{i,p}\cos(\frac{p-1}{2}t) & \text{若} p \text{为奇数}\\
\frac{X_{i,1}}{\sqrt{2}}+X_{i,2}\sin(t)+X_{i,3}\cos(t)+\cdots\\
\qquad+X_{i,p}\sin(\frac{p}{2}t) & \text{若} p \text{为偶数}
\end{cases} 
(\#eq:andrews-curve)
\end{equation}

\noindent 其中 $t\in[-\pi,\pi]$。

这样一来，将 $t$ 取一系列值，则每一行观测数据都可以画出一条曲线，最终可以得到 $n$ 条曲线，也就形成了调和曲线图。这种数学转化表面上看起来很不直观，然而它却有很多好的数学性质及对应的实际意义，这里仅列举两条：

1.  如果我们用 $L_{2}$ 范数来度量两条曲线之间的距离，那么得到的距离值正好是欧氏距离平方的 $\pi$ 倍。换句话说，两行观测之间的距离恰好可以表现为图中两条曲线之间的差距。这条性质使得我们可以直观地在图中观察聚类现象和离群点，因为聚类和离群点的概念都是基于距离的（距离的定义有多种，这里用欧氏距离的平方）。如果读者感兴趣，可以验证一下这个 $L_{2}$ 范数的结果：
    $$\int_{-\pi}^{\pi}\left(f_{i}(t)-f_{j}(t)\right)^{2}dt=\pi\sum_{k=1}^{p}\left(X_{i,k}-X_{j,k}\right)^{2}$$

2.  这个变换从一定程度上保持了线性的性质，即：若一个观测 $X_{l}$ 的所有数值都小于 $X_{i}$ 而大于 $X_{j}$，那么在调和曲线图上 $X_{l}$ 对应的曲线也位于 $X_{i}$ 和 $X_{j}$ 之间。这一点性质是非常明显的。

### 示例 {-}

图 \@ref(fig:andrews-curve)
展示了鸢尾花数据（表 \@ref(tab:tab-iris)）和黑莓树数据（表 \@ref(tab:tab-trees)）这两个多维数据的调和曲线图。前者在 \@ref(sec:sunflowerplot) 小节已有介绍；后者是 31 种黑莓树的周长、高度和体积数据。

```{r tab-trees}
data(trees)
kable2(trees, "31 种黑莓树的周长、高度和体积数据")
```

(ref:fig-andrews-curve-s) 鸢尾花数据和黑莓树数据的调和曲线图

(ref:fig-andrews-curve) 鸢尾花数据和黑莓树数据的调和曲线图：左上为原始鸢尾花数据，右上为调整变量顺序的鸢尾花数据，左下为标准化之后的鸢尾花数据，右下为标准化之后的黑莓树数据调和曲线图

```{r andrews-curve,fig.width=6,fig.height=4.8,fig.cap="(ref:fig-andrews-curve)",fig.scap="(ref:fig-andrews-curve-s)",dev='tikz',fig.showtext=FALSE,fig.process=to_png}
msg_graph("andrews-curve-tikz")
```

左上图为原始鸢尾花数据的前四列，并根据鸢尾花的种类对曲线进行了颜色标注。可以看出，setosa 这一类花的曲线"拧"成了一股，说明这些花之间的距离比较近，即我们至少可以观察到这一类的聚类现象。右上图调整了四列的顺序，将花瓣长和花瓣宽两个变量放在了前面，这样做的原因我们后面再解释。

我们首先可以看到，调整顺序后的鸢尾花调和曲线图发生了变化，曲线的振幅和频率都加大了。这跟数据各列的性质有关。鸢尾花数据有四列，我们可以写出曲线的函数表达式：
$$f_{i}(t)=\frac{X_{i,1}}{\sqrt{2}}+X_{i,2}\sin(t)+X_{i,3}\cos(t)+X_{i,4}\sin(2t)$$

我们知道，$\sin(kt)$ 中的 $k$ 越大，则三角函数曲线的频率越高，而每个三角函数前面的系数越大，则振幅越大。鸢尾花数据前四列的简单汇总信息如下：

```{r iris-summary}
summary(iris[, 1:4])
```

平均来说，第 1、2 列花萼比第 3、4 列花瓣的长宽数值要大。右上图中，由于大数值赋给了 $\sin(2t)$ 的系数，所以这一项相对占了主导地位，因此曲线频率加大；同时，由于曲线表达式的第一项理论上取值无界（后面所有项都受三角函数取值界限限制），所以它往往很大程度上影响了曲线的振幅，右图中将小值给了第一项，所以振幅相对左上图加大了。右上图的另一个特征是，setosa 类的曲线几乎一致"拧"在所有曲线之下，这也使得观察聚类更方便。

为什么要把第 3、4 列调到前面来呢？主要是因为鸢尾花的四个属性中，用花瓣长宽最易区分各类花。这一点我们可以用分类树验证一下：

```{r iris-rpart, echo=TRUE}
library(rpart)
print(rpart(Species ~ ., iris), digits = 2)
```

在数据各列的数量级都差不多的时候， \@ref(eq:andrews-curve) 式越靠前的变量越能控制曲线的位置，越靠后的变量越能控制曲线的波动，而我们通常并不关心调和曲线图中的波动，仅仅观察曲线是否"拧成股"，所以在安排变量顺序的时候，通常把对聚类有重要贡献的变量放在前面，这样调和曲线图对读者来说才能有更好的可读性。

图 \@ref(fig:andrews-curve)
左下图是将鸢尾花数据标准化之后的调和曲线图。由于数据的数量级更加靠近，所以曲线之间的差异也更明显，导致各股曲线更加松散。右下图是标准化之后的黑莓树数据调和曲线图。从图中我们可以观察到有一条曲线明显与其它曲线"不合群"，因此可以初步判断它是一个离群点，由于这条曲线的数值能够超过 4，我们可以用函数返回值来查找它对应的行（事实是第 31 行），代码见下文。

### 绘制方法 {-}

我们自行编写的 **MSG** 包中的 `andrews_curve()` 函数可以用来绘制调和曲线图。它的用法如下：

```{r andrews-curve-usage, results='asis'}
library(MSG)
usage2(usage(andrews_curve, output = FALSE))
```

\noindent 参数含义：

`x`:
: 数据矩阵。

`n`:
: 画曲线时 $t$ 在 $[-\pi,\pi]$ 区间上取点的个数，取点越多则曲线越光滑。

其它所有参数（包括 ... 参数）都将传递给矩阵图函数 `matplot()`，用以画每条观测数据的曲线。

图 \@ref(fig:andrews-curve) 的绘制代码如下：

```{r, results='asis'}
msg_code("andrews-curve")
```

离群点是哪行数据？即哪行数据对应的 $f(t)$ 会大于 4？很简单：

```{r, echo=TRUE}
which(apply(x > 4, 1, any))
```

注意：`andrews_curve()` 函数会返回所有行（每条观测）在每个 $t$ 值上对应的 $f_{i}(t)$ 值，我们可以根据这个返回值来判断图中各条曲线对应的行。

## 地图 {#sec:maps}

### 概述 {-}

毫无疑问，地图是展示地理信息数据时最直观的工具，尤其是当地图和统计量结合时，其功效则会进一步加强。在本书的第\@ref(cha:history)章中曾经提到过 John Snow 的地图，注意图中不仅标示出了霍乱发生的地点，每个地点的死亡人数也用点的数目标示了出来。
历史上还有不少类似的使用地图的例子，而在今天，地理信息系统（GIS）已经成为研究空间和地理数据的热门工具，地图的应用也是屡见不鲜。

### 示例 {-}

表 \@ref(tab:tab-map) 给出了 2005 年世界各国家地区的农业进出口竞争力指标数据 [@Xie07]。其中，我们将竞争力指标简单定义为（出口$-$进口）/（出口$+$进口）。我们将这组数据在图 \@ref(fig:map) 上标示出来。从图中可以看出，阿根廷、巴西等南美国家的农业进出口竞争力较强，而利比亚、阿尔及利亚等北非国家的竞争力较弱。

```{r tab-map}
source(system.file("extdata", "AgriComp.R", package = "MSG"))
kable2(AgriComp, "2005 年世界各国农业进出口竞争力")
```

(ref:fig-map-s) 2005 年世界各国农业进出口竞争力地图

(ref:fig-map) 2005 年各国农业进出口竞争力地图：农业出口强国在南美，弱国在北非

```{r map,fig.width=6,fig.height=4,fig.cap="(ref:fig-map)",fig.scap="(ref:fig-map-s)",error=TRUE,results='hide'}
msg_graph("map2")
```

### 绘制方法 {-}

地图的本质是多边形（\@ref(sec:polygon) 小节），而多边形的边界则由地理经纬度数据确定。R 中绘制地图的传统附加包是 **maps** [@maps]，核心的函数为 `map()` ，它的用法如下：

```{r map-usage, results='asis'}
library(maps)
usage2(usage(map, output = FALSE))
```

该函数的两个主要参数为地图数据库 `database` 和地图区域 `region` 。地图数据库中包含了所有区域的经纬度数据以及相应的区域名称。在指定一个数据库和一系列区域名称之后，这些区域的地图便可由 `maps()` 生成。其它参数诸如填充颜色、是否画边界、是否添加到现有图形上等这里就不再介绍，请读者参考帮助文件。

运行下面的代码可以将表 \@ref(tab:tab-map) 的数据绘制成地图：

```{r, results='asis'}
msg_code("map")
```

上述代码的大致制作过程为：首先我们用 `world` 数据库作出一幅空白的世界地图，地区边界用灰色线条表示，然后我们根据竞争力数据中的地区名称与地理数据库中地区名称的对应将数据以颜色的形式表示到世界地图中，最后我们在图中添加了赤道线以及东盟国家（ASEAN）的矩形区域，这是由于作为该图出处的会议论文 [@Xie07] 主题是中澳自由贸易区。

**maps**包功能虽然比较完善，但绘制地图的过程仍然有些繁琐。近年来，**ggplot2** 发展迅猛，其地图绘制功能也越来越强大了。图 \@ref(fig:map) 实际是用 **ggplot2** 包绘制多边形的方式作出来的，代码如下：

```{r, results='asis'}
msg_code("map2")
```

这里，`coord_quickmap()` 函数，专门用作地图坐标，确保地图上的经度和纬度之比符合常用的摩克托投影规则。此外，**ggplot2** 还提供了另外一个坐标转换函数` coord_map()`，功能更复杂一些。如图 \@ref(fig:worldmap) 所示，上图是平面地图，下图是以北纬 20° 东经 90° 视角看到的球状地图。生成这两幅地图的代码如下：

```{r, results='asis'}
msg_code("worldmap")
```

(ref:fig-worldmap-s) 不同视角和投影下的世界地图

(ref:fig-worldmap) 不同视角和投影下的世界地图：上图是平面地图，下图是以北纬 20° 东经 90° 视角看到的球状地图

```{r worldmap,fig.width=6,fig.height=8,fig.cap="(ref:fig-worldmap)",fig.scap="(ref:fig-worldmap-s)",error=TRUE,results='hide', fig.show='hold'}
msg_graph("worldmap")
```

在地理区域上标记大量的数值信息会遇到一个显而易见的困难，就是由于各个地理区域的面积不同而导致地图的解读失真或某些重要地理单元难以辨认。例如，我们在画中国省级地图时，北京和上海等直辖市相比其它省份显得面积太小，此时若用颜色来标记某个数值指标（如 GDP），就会使得各个直辖市的颜色几乎无法辨认。

一个更有趣的例子来自 2008 年美国总统大选，如图 \@ref(fig:state-map)。若用红蓝两种颜色对各个州做标记，以表示该州支持麦凯恩或奥巴马，那么有些面积不大但是权重很大的州（如人口众多的加州）就会影响整幅美国地图。从原始地图上看，似乎麦凯恩会赢，因为他赢得了很多中部面积大的州（但人口稀少），整幅地图看起来以红色为主导；若我们保持州的相对地理位置不变，将各个州的形状进行大小的调整，使其面积与权重成正比，此时红蓝两色的局面就发生了逆转，地图以蓝色为主导色，地图传达信息的偏误才得到了纠正。我们把这种保持地理区域的相对位置不变、调整区域面积与某指标成比例的地图成为"变形地图"（Cartogram），详细内容可阅读笔者的博客[^map-prob]。

[^map-prob]: <https://yihui.org/cn/2009/03/cartogram-as-special-maps/>

(ref:state-map) 2008 年美国总统大选各州投票情况：红蓝两种颜色分别表示该州支持麦凯恩或奥巴马。左图是正常地图，麦凯恩赢得了很多中部面积大的州（但人口稀少），整幅地图看起来以红色为主导；右图为变形地图，保持了地理区域的相对位置不变而调整区域面积与权重成比例，地图以蓝色为主导色

(ref:state-map-s) 2008 年美国总统大选各州投票情况

```{r state-map, out.width="49%",fig.cap="(ref:state-map)", fig.scap="(ref:state-map-s)", fig.show='hold'}
knitr::include_graphics(c("images/statemapredbluer1024.png", "images/statepopredblue1024.png"))
```

除了 **maps** 包和 **ggplot2** 包之外，R 语言还有更多的地图绘制系统，例如 **RgoogleMaps** 包 [@RgoogleMaps]，将 Google Maps 提供的（卫星）地图数据引入 R 中，这里简单介绍一下。

首先，此包利用 Google Maps API，为 R 提供了一个十分便利的接口，以抓取 Google 服务器上的静态地图；其次，用户可使用获得的地图作为背景，在其上方自由叠加图形元素。对于一般的经纬度坐标数据，此包可计算包含这些数据点的矩形边界，以确定抓取地图的范围。其工作流程概括如下：

-   读取经纬度数据
-   通过计算确定获取图片所需参数
-   访问 Google Maps 服务器抓取图片
-   依据经纬度数据在图片上叠加图形元素

下面我们举一个利用 **RgoogleMaps** 包的例子。

表 \@ref(tab:tab-eq2010) 给出了来自中国国家地震科学数据共享中心的 354 条四川地区地震数据示例。3 个变量分别为震源的纬度、经度和震级大小（单位：面波震级 Ms），时间跨度为 2010 年 3 月 23 日到 2010 年 4 月 23 日。

```{r tab-eq2010}
data(eq2010, package = "MSG")
kable2(eq2010, "四川地区地震数据")
```

图 \@ref(fig:RgoogleMaps) 显示了地震震源位置分布情况，背景采用了 Google Maps 提供的卫星地图数据。左图仅仅体现了震源位置的分布情况，不妨考虑将震级的大小映射为圆的半径大小。然而，图中存在着部分地震多发地带，如果使用圆来呈现震源的位置，这些区域的圆将出现严重的叠加现象，此处可以尝试使用 \@ref(sec:plot) 节中的透明度叠加来克服这类重叠问题，如右图所示。这里由于数据量不够大，这种透明度叠加的效果并不是非常明显。

本节具体的代码参见 `eqMaps` 演示：

```{r eqMaps-demo,results='asis'}
msg_code("eqMaps-demo")
```

```{r RgoogleMaps,fig.cap="(ref:RgoogleMaps)",fig.scap="(ref:RgoogleMaps-s)",echo=FALSE,fig.subcap=c("",""),out.width="45%"}
knitr::include_graphics(path = c(
  "images/RgoogleMaps-1.png",
  "images/RgoogleMaps-2.png"
))
```

(ref:RgoogleMaps) 在卫星地图上标记地震发生的地点和震级：左图仅标记地点，右图用圆圈大小代表震级大小

(ref:RgoogleMaps-s) 在卫星地图上标记地震发生的地点和震级

**RgoogleMaps** 包的潜力仍尚待挖掘。一方面，它可以展示空间分布信息，例如在 2010 年的 **ggplot2** 案例分析竞赛中，David Kahle 利用 **RgoogleMaps** 包和公开的犯罪信息数据，展示了休斯顿地区暴力犯罪的分布情况[^4]；另一方面，如果数据包含时间属性，那么我们可以固定住抓取图片的边界，并保证叠加元素的坐标对应正确，便能制作出有用的动画。读者可以发挥想象力，拓展更多的应用情境。

[^4]: <http://1t.click/Ksb>

本节只是介绍了一个非常简单的应用，但也引出了一个重要话题：统计图形如何与它要表达的问题的背景相融合？用通俗的话讲，就是要找"应景"的背景。在这方面，图 \@ref(fig:pork-price-orig) 实际上做得很好，很有吸引眼球的效果，让人一看就明白要表达的主题。当然，背景元素也不能喧宾夺主，这一点在 \@ref(subsec:element-priority) 小节中有详细论述。

## 思考与练习

1.  自行编写一个画三元图的函数，并体会这种从三维到二维的变换。以下是不完整的代码，核心部分已经完成，需要实现控制边长范围和坐标网格线等功能：

```{r triplot-fun, eval=FALSE, echo=TRUE}
triplot = function(x, ...) {
  x = as.matrix(x)
  x = x / rowSums(x) # 将行之和标准化到 1
  plot(x[, 2] + x[, 3] / 2, x[, 3] * sqrt(3) / 2, asp = 1, 
        ann = FALSE, axes = FALSE, xlim = c(0, 1), 
        ylim = c(0, sqrt(3) / 2), ...)
  polygon(c(0, 1, 1 / 2), c(0, 0, sqrt(3) / 2))
}
# 测试数据
data(murcia, package = "MSG")
triplot(murcia[, 2:4], col = vec2col(murcia$site), pch = 19)
```


2. **ggplot2** 并没有现成的函数来绘制条件分割图。不过，下面的代码可以做出类似的效果，如图 \@ref(fig:coplot2)。比较一下，这幅图与图 \@ref(fig:coplot) 的区别在哪里？能得出相同的结论吗？如何更改这段代码，以做出图 \@ref(fig:coplot)？

```{r, results='asis'}
msg_code("coplot2")
```

(ref:fig-coplot2) 使用 **ggplot2** 包绘制的地震经纬度条件分割图

```{r coplot2, fig.cap="(ref:fig-coplot2)", dev='tikz', fig.showtext = FALSE}
msg_graph("coplot2")
```
