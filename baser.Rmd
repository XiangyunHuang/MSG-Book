# R 基础作图系统 {#cha:elements}

> 　　他从信封里拿出一页四折叠的半张 $13\times17$ 英寸的信纸。他把信纸打开铺在桌上，中间有一行铅字拼贴成的句子： 
>
>     　　若你看重自己生命的价值或还有理性，那就远离沼地。
> 
> 只有“沼地”两个字是用墨水写的。
>
> 　　“现在，”亨利 $\cdot$ 巴斯克维尔爵士说，“福尔摩斯先生，也许您可以告诉我，这是什么意思，到底是谁对我的事这么感兴趣呢？”
> 
> 　　……“可是，亲爱的华生，两者之间的联系非常紧密，短信中的每个单字都是从这个长句中抽出来的。例如：‘你’、‘你的’、‘生’、‘命’、‘理性’、‘价值’、‘远离’等，你现在还看不出这些字是从那里面弄来的吗？”
> 
> 　　“天啊！太对了！唉呀，您可聪明绝顶！”亨利爵士喊了起来。
> 
> ——柯南 $\cdot$ 道尔《巴斯克维尔的猎犬》

R 语言绘制的统计图形都是通过相应的图形函数生成的。很多图形函数都包含了默认的图形细节设置，这些细节对不太苛刻的用户来说大致可以满足需要，但是往往由于其它方面的要求（如排版、强调某一部分），我们可能要对图形作一些细节性的微调，比如字体、字号、图形边距、点线样式等等。本章介绍 R 语言基础图形系统中的细节参数设置。

另外，我们也在这里介绍一些统计作图上的技巧。这些技巧对于数据分析来说也许没有显著的作用，但它们可以帮我们进一步调整、组织好我们的图形输出。这些内容包括：数学公式的表示、一页多图的方法、离散变量的散点图示和各种图形设备的使用方法。


## 作图函数

在本书第二部分，我们介绍了很多 R 基础作图函数，如
条形图函数 `barplot()`（\@ref(sec:barplot) 小节）、
直方图函数 `hist()` （\@ref(sec:hist) 小节）、
箱线图函数 `boxplot()`（\@ref(sec:boxplot) 小节）、
向日葵散点图函数 `sunflowerplot()`（\@ref(sec:scatterplot-matrix) 小节）、
等高图函数 `contour()`（\@ref(sec:contour) 小节）、
颜色图函数 `image()`（\@ref(sec:image) 小节）等。

R 中最普通的作图函数是 `plot()` 函数。R 的很多图形参数可以用 `par()` 函数来查看和设置。本节重点讲述一下这两个函数的用法，相信读者可以举一反三，在深入了解这两个函数之后，能够理解其它作图函数的用法规律。

### `plot()` 函数 {#sec:plot}

`plot()` 是一个泛型函数，可以接受很多不同类的对象作为它的作图对象参数。我们这里要解释的只是其中的图形参数，而非作图对象参数。

`plot()` 的通用参数有：

`type`
: 图形样式类型，有九种可能的取值，分别代表不同的样式：

  - `"p"`$\Rightarrow$ 画点；
  - `"l"`$\Rightarrow$ 画线[^line-type]；
  - `"b"`$\Rightarrow$ 同时画点和线，但点线不相交；
  - `"c"`$\Rightarrow$ 将 `type = "b"` 中的点去掉，只剩下相应的线条部分；
  - `"o"`$\Rightarrow$ 同时画点和线， 且相互重叠，这是它与 `type = "b"` 的区别；
  - `"h"`$\Rightarrow$ 画铅垂线；
  - `"s"`$\Rightarrow$ 画阶梯线，从一点到下一点时，先画水平线，再画垂直线；
  - `"S"`$\Rightarrow$ 也是画阶梯线，但从一点到下一点是先画垂直线，再画水平线；
  - `"n"`$\Rightarrow$ 作一幅空图，没有任何内容，但坐标轴、标题等其它元素都照样显示（除非用别的设置特意隐藏了）。
  
  图 \@ref(fig:plot-type) 的九幅图清楚说明了这九种类型。笔者开发的 **beginr** [@beginr] 包提供了函数 `plottype()`，可以方便地查询这九种图形样式，安装后运行 `beginr::plottype()` 即可。

(ref:plot-type-s) `plot()` 作图的九种样式

(ref:plot-type) `plot()` 作图的九种样式类型：点、线、点线（不相接）、擦掉点的线、点线（相接）、垂线、阶梯（水平起步）、阶梯（垂直起步）、无

```{r plot-type,fig.cap="(ref:plot-type)",fig.scap="(ref:plot-type-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("plot-type")
```

`main`、`sub`、`xlab`、`ylab`:
: 主标题、副标题、x 轴标题、y 轴标题。也可以在作图之后用函数 `title()` 添加，参见 \@ref(sec:text) 节。

`asp`
: 图形纵横比，即 y 轴上的 1 单位长度和 x 轴上 1 单位长度的比率。通常情况下，这个比率不是 1。有些情况下需要设置以显示更好的图形效果，例如需要从角度表现直线的斜率。若 `asp` 不等于 1，那么 $45^{\circ}$ 的角可能看起来并不像真实的 $45^{\circ}$。 

[^line-type]: 注意是字母 `l`（表示“line”）， 不是数字 1！同样后面的字母 `o`（表示“overplotted”）也不要误认为是数字 0

然后，我们看看默认的散点图函数 `plot.default()`。对于一般的散点图（两个数值变量之间），我们只需要调用 `plot()` 即可，如 `plot(x, y)`，而不必写明 `plot.default(x, y)`，原因就是 `plot()` 是泛型函数，它会 自动判断传给它的数据类型从而采取不同的作图方式。`plot.default()` 的参数当然包含了前面介绍的 `plot()` 中那些参数，此外还有：

`x, y`
: 欲作散点图的两个向量。如果 y 缺失，那么就用 x 对它的元素位置（`1:n` 的整数）作散点图。

`xlim, ylim`
: 设置坐标系的界限，两个参数都取长度为 2 的向量。它们的作用类似 `par()` 中的 `usr` 参数，但我们可以通过 `par()$usr` 获得一幅图的坐标系界限，而这里的两个参数就没有这个功能了，因为一般来说作图函数不会返回任何值（或者说返回值为空：`NULL`）。

`log`
: 坐标是否取对数。取值`"x"`表示横坐标取对数，`"y"`表示 纵坐标取对数，`"xy"`表示两个坐标轴都取对数。

`ann`
: 一些默认的标记是否显示，如坐标轴标题和图标题。

`axes`
: 是否画坐标轴。注意只会影响是否画出坐标轴线和刻度，不会影响坐标轴标题。

`frame.plot`
: 是否给图形加框。可以查阅 `box()` 函数，作用类似但功能更详细。

`panel.first`
: 在作图前要完成的工作。这个参数常常用来在作图之前添加背景网格（参见 \@ref(sec:grid) 节）或者添加散点的平滑曲线，比如 `panel.first = grid()`。

`panel.last`
: 作图之后要完成的工作，与上一个参数类似。

`col, pch, cex, lty, lwd`
: 这些参数的意思详见`par()`函数（\@ref(sec:par) 小节），区别在于，`par()` 中这些参数只能设置一个单值，而这里可以对它们设置一个向量，这个向量的值将依次运用到各个元素上。若向量长度短于元素个数，那么向量会被循环使用，直到所有的元素都被画出来。事实上，向量的循环使用也是 R 图形参数的一大特点。
    
`bg`
: 背景色。注意：与 `par()` 不同的是，这里设置的只是可以画背景色的点的背景色，而不是设置整幅图形的背景色！ \@ref(sec:points) 节中说明了什么类型的点可以画背景色。


### `par()` 函数 {#sec:par}

R 的图形参数既可以通过函数 `par()` 预先全局设置，也可以在具体作图函数（如 `plot()`、`lines()` 等）中设置临时参数值。二者的区别在于：前者的设置会一直在当前图形设备中起作用，除非将图形设备（参见 \@ref(sec:device) 小节）关闭；而后者的设置只是临时性的，不会影响后面其它作图函数的图形效果。

函数 `par()` 中涵盖了大部分图形参数，因此专用一节讲述。

`par()` 可以用来设置或者获取图形参数。`par()` 本身（括号中不写任何参数）返回当前的图形参数设置（一个 list）；若要设置图形参数，则可用 `par(tag = value)` 的形式， 其中 tag 的详细说明参见下面的列表，value 就是参数值， 例如：

```{r par-example,eval=FALSE, echo=TRUE}
# 设置边距参数和背景色
par(mar = c(4, 4, 1, .5), bg = "yellow")
```

目前 `par()` 函数涉及的图形参数大约有 70 个，这里只是选取其中 40 多个常用且较易理解的参数进行解释说明如下，其它参数请参阅 R 帮助 `?par`。

\noindent 参数含义：

`adj`
: 调整图中字符的相对位置。取值为长度为 1 的数值向量，范围通常在 $[0,1]$ 中，0 表示左对齐，1 表示右对齐。在 `text()` 函数中，该参数的长度可以为 2，分别表示字符边界矩形框的左下角相对坐标点 (x, y) 位置的调整，向量的两个数值一般也在 $[0,1]$ 范围中（有些图形设备中也可以超出此范围），表示字符串以左下角为基准、根据自身的宽度和高度分别向左和向下移动的比例，默认为 `c(0.5, 0.5)`。例如 `c(0, 0)` 表示整个字符（串）的左下角对准设定的坐标点，而 `c(1, 0)` 则表示字符串横向移动了自身宽度的距离，而纵向不受影响。具体示例参见图 \@ref(fig:par1) 左上图。


(ref:par1-s) 参数 `adj`、`mgp`、`tcl` 和 `ljoin` 设置演示

(ref:par1) 左上：`adj` 用于字符相对位置的调整，“+”表示真实坐标点的位置，通过一个长度为 2 的向量 `c(x, y)` 可以分别调整字符在横纵坐标上相对平移的位置；右上：坐标轴元素的边界距离，参数 `mgp` 的三个数值分别控制了坐标轴标题、坐标轴刻度数字以及坐标轴线到图形的距离；左下：`tcl` 控制了坐标轴刻度线的方向和长度，`srt` 控制了字符串的旋转角度；右下：线条相交处的样式

```{r par1,fig.height= 7, fig.width=7,  fig.cap="(ref:par1)",fig.scap="(ref:par1-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("par1")
```

`ask`
: 切换到下一个新的作图设备（通常是作一幅新图）时是否需要用户输入（敲回车键或点鼠标）：TRUE 表示“是”，FALSE 表示“否”。当有多幅图将逐一出现而需要按顺序一步步在图形设备上展示时很有用，这种情况下若设置 `ask` 为 `TRUE`，那么作图时每一副新图的出现都要先等待用户输入，否则所有的图将会一闪而过。

`bg`
: 设置图形背景色；关于颜色值的设置请参见 \@ref(sec:color) 节。

`bty`
: 设置图形边框样式，取值为字符 `"o"`, `"l"`, `"7"`, `"c"`, `"u"`, `"]"` 之一。 这些字符本身的形状对应着边框样式，比如`"o"`（默认值） 表示四条边都显示，而 `"c"` 表示不显示右侧边。参见图 \@ref(fig:par2) 四幅图的边框样式。

(ref:par2-s) 其它主要参数的效果演示：`bty`，`font`，`las`，`family` 等

(ref:par2) 四幅图形演示了不同的图形边框（上右开、上右闭、右开和上开）、字体样式（正常、粗体、斜体和粗斜体）、字体族（衬线、无衬线、等宽、符号）、坐标轴标签样式、点样式（圆圈、方框、菱形、三角）、线末端样式和线样式（实线、虚线、点线、点划线）

```{r par2,fig.height=7, fig.width=7, fig.cap="(ref:par2)",fig.scap="(ref:par2-s)"}
msg_graph("par2")
```

`cex`
: 图上元素（文本和符号等）的缩放倍数，取值为一个相对于 1 的数值（默认为 1）。具体的细节缩放可以通过如下参数设置（默认值均为 1）：

    `cex.axis`
    : 坐标轴刻度标记的缩放倍数
    
    `cex.lab`
    : 坐标轴标题的缩放倍数
    
    `cex.main`
    : 图主标题的缩放倍数
    
    `cex.sub`
    : 图副标题的缩放倍数

`col`
: 图中符号（点、线等）的颜色，取值参见 \@ref(sec:color) 节。与 `cex` 参数类似，具体的细节颜色也可以通过如下参数设置：

    `col.axis`
    : 坐标轴刻度标记的颜色
    
    `col.lab`
    : 坐标轴标题的颜色
    
    `col.main`
    : 图主标题的颜色
    
    `col.sub`
    : 图副标题的颜色

`family`
: 设置文本的字体族（衬线、无衬线、等宽、符号字体等）。标准取值有：`serif, sans, mono, symbol`。参见图 \@ref(fig:par2) 坐标 `(2, 8)` 处的文本。`family = "symbol"` 的情况没有显示出来。

`fg`
: 设置前景色。若后面没有指定别的颜色设置，本参数会影响几乎所有的后续图形元素颜色；若后续图形元素有指定的颜色设置，那么只是影响图形边框和坐标轴刻度线的颜色。颜色值参见 \@ref(sec:color) 节。

`font`
: 设置文本字体样式，取值为一个整数。通常 1、2、3、4 分别表示正常、粗体、斜体和粗斜体。对于添加文本，`text()` 函数及其 `vfont` 参数可以设置更为详细的字体族和字体样式；参见这两个演示：`demo(Hershey)` 和 `demo(Japanese)`，前者演示 Hershey 向量字体，后者演示日语的表示。\@ref(sec:text) 节有进一步的介绍。参见图 \@ref(fig:par2) 的图主标题字体。

    `font.axis`
    : 坐标轴刻度标签的字体样式
    
    `font.lab`
    : 坐标轴标题的字体样式
    
    `font.main`
    : 图主标题的字体样式
    
    `font.sub`
    : 图副标题的字体样式

`lab`
: 设置坐标轴刻度数目（R 会尽量自动“取整”，即尽量向 0.5、1 或 10 的幂次靠近），取值形式 `c(x, y, len)`：`x` 和 `y` 分别设置两轴的刻度数目，`len` 目前在 R 中尚未生效，因此设置任意值都不会有影响（但用到 `lab` 参数时必须写上这个参数）。

`las`
: 坐标轴标签样式。取 0、1、2、3 四个整数之一，分别表示“总是平行于坐标轴”、“总是水平”、“总是垂直于坐标轴”和“总是竖直”。仔细观察图 \@ref(fig:par2) 中四幅图的不同坐标轴标签方向。

`lend`
: 线条末端的样式（圆或方形），取值为整数 0、1、2 之一（或相应的字符串 `"round"`, `"mitre"`, `"bevel"`），注意后两者的细微区别（仔细观察图 \@ref(fig:par2) 中宽线条中黑点的位置，在画线时，这些线条的起点和终点都是选择同样的坐标位置！）。

`lheight`
: 图中文本行高，取值为一个倍数，默认为 1。

`ljoin`
: 线条相交处的样式，取值为整数 0、1、2 之一（或相应的字符串 `"round"`, `"mitre"`, `"bevel"`），分别表示画圆角、画方角和切掉顶角。观察图 \@ref(fig:par1) 的三个直角的顶点。

`lty`
: 线条虚实样式：$0\Rightarrow$ 不画线，$1\Rightarrow$ 实线，$2\Rightarrow$ 虚线，$3\Rightarrow$ 点线，$4\Rightarrow$ 点划线，$5\Rightarrow$ 长划线，$6\Rightarrow$ 点长划线。**beginr** 包的 `beginr::plotlty()` 函数展示了这六种线的样式。也可以设置为如下字符串（分别对应前面的数字）：`"blank"`, `"solid"`, `"dashed"`, `"dotted"`, `"dotdash"`, `"longdash"`, `"twodash"`。还可以用由十六进制的数字组成的字符串表示线上实线和空白的相应长度，如 `"F624"`。 详细解释请参见 \@ref(sec:lines) 一节。

`lwd`
: 线条宽度，默认为 1。

`mar`
: 设置图形边界空白宽度。按照“下、左、上、右”的顺序，默认为 `c(5, 4, 4, 2) + 0.1`。

`mex`
: 设置坐标轴的边界宽度缩放倍数，默认为 1。本参数会影响到 `mgp` 参数。

`mfrow, mfcol`
: 设置一页多图，长度为 2 的向量，取值形式 `c(nrow, ncol)`，分别设置行数和列数。参见 \@ref(sec:multipage) 节。

`mgp`
: 设置坐标轴的边界宽度。取值长度为 3 的数值向量，分别表示坐标轴标题、坐标轴刻度线标签和坐标轴线的边界宽度（受 `mex` 的影响），默认为 `c(3, 1, 0)`，意思是坐标轴标题、坐标轴刻度线标签和坐标轴线离作图区域的距离分别为 3、1、0。参见图 \@ref(fig:par1) 右上方小图。

`oma`
: 设置外边界（Outer Margin）宽度，类似 `mar`，默认为 `c(0, 0, 0, 0)`。当一页上只放一张图时，该参数与 `mar` 不好区分，但在一页多图的情况下就容易可以看出与 `mar` 的区别。

`pch`
: 点的符号。`pch = 19`$\Rightarrow$ 实圆点、`pch = 20`$\Rightarrow$ 小实圆点、pch = $21\Rightarrow$ 圆圈、`pch = 22`$\Rightarrow$ 正方形、`pch = 23`$\Rightarrow$ 菱形、`pch = 24`$\Rightarrow$ 正三角尖、`pch = 25`$\Rightarrow$ 倒三角尖。其中，21-25 可以填充颜色（用 `bg` 参数）。**beginr** 包的 `beginr::plotpch()` 函数列出了这些数字代表的点的形状。参见图 \@ref(fig:point-type)。

`pty`
: 设置作图区域的形状。默认为 `"m"`：尽可能最大化作图区域。另外一种取值 `"s"` 表示设置作图区域为正方形。

`srt`
: 字符串的旋转角度，取一个角度数值，参见图 \@ref(fig:par1) 左下方小图中分别旋转 $30\,^{\circ}$ 和 $120\,^{\circ}$ 的字符串。

`tck`
: 坐标轴刻度线的高度，取值为与图形宽高的比例值（0 到 1 之间）。正值表示向内画刻度线，负值表示向外。默认为不使用它（设为 `NA`），而使用 `tcl` 参数。

`tcl`
: 坐标轴刻度线的高度，取一个与文本行高的比例值。正负值意义类似 `tck`，默认值为 `-0.5`，即向外画线，高度为半行文本高。观察图 \@ref(fig:par1) 左下角小图的坐标轴刻度线。

`usr`
: 作图区域的范围限制，取值长度为 4 的数值向量 `c(x1, x2, y1, y2)`，分别表示作图区域内 x 轴的左右极限和 y 轴的下上极限。注意，若坐标取了对数（参见 `xlog, ylog` 两个参数），那么实际上设置的极限都是 10 的相应幂次。

`xaxs, yaxs`
: 坐标轴范围的计算方式，默认 `"r"`：先把原始数据的范围向外扩大 4\%，然后用这个范围画坐标轴。另外一种取值 `"i"` 表示直接使用原始数据范围。实际上还有其它的坐标轴范围计算方式，但是鉴于它们目前在 R 中都尚未生效，所以暂不加介绍。

`xaxt, yaxt`
: 坐标轴样式。默认 `"s"` 为标准样式；另外一种取值 `"n"`，意思是不画坐标轴。

`xlog, ylog`
: 坐标是否取对数。默认 `FALSE`。

`xpd`
: 对超出边界的图形的处理方式。取值 `FALSE`表示把图形限制在作图区域内，出界的图形截去；取值 `TRUE`表示把图形限制在图形区域内，出界的图形截去；取值 `NA`表示把图形限制在设备区域内。这些区域的说明参见下文和图 \@ref(fig:plot-region)。


(ref:plot-region-s) 图形的各种区域说明

(ref:plot-region) 图形的各种区域和边界说明：作图区域（当前作图区域）、图形区域和设备区域；图形边界和外边界

```{r plot-region,fig.width=7, fig.height=3.5, echo=FALSE,fig.cap="(ref:plot-region)",fig.scap="(ref:plot-region-s)", dev='tikz', fig.showtext = FALSE}
msg_graph("plot-region")
```


整个作图设备实际上可以分为三个区域，分别是“作图区域（Plot Region）”、“图形区域（Figure Margin）”和 “设备区域（Device Region）”。这三个区域也对应着两种边界：“图形边界（Figure Margin）”和 “外边界（Outer Margin）”。这些概念对于初学者来说可能会感到迷惑，然而图 \@ref(fig:plot-region) 是一个很好的说明。

- R 中的图形都是作在一个图形设备中，最常见的图形设备就是一个图形窗口，也可以在其它设备中（参见 \@ref(sec:device) 小节）；整个设备内的区域就称为设备区域，也就是图 \@ref(fig:plot-region) 中最大的灰色区域。
- 图形区域是设备区域内的白色实框方形区域。
- 最里面的灰色虚框区域就是作图区域，我们的图形实体部分就作在这个区域。

从设备区域的边界向内，到图形区域之间这一段称为外边界（用 `oma` 参数设定），图形区域边界再向内到作图区域的边界称为图形边界（用 `mar` 参数设定）。图 \@ref(fig:plot-region) 的左图是一页一图的展示，右图则是一页多图的展示，该展示更清楚地说明了 `oma` 与 `mar` 参数的区别，因为一页一图的情况下，外边界和图形边界完全融合在一起，很难分辨。

下面列表中的九组参数只能通过 `par()` 函数调用，而在其它作图函数中不可设置（否则会导致错误或者被忽略）。与此对应的是，有些参数同样可以在别的作图函数中调用， 如 `las` 参数：`plot(..., las = 1)`。但要提醒读者注意，在其它函数中即使调用与 `par()` 相同的参数，也可能会有不同效果，典型的如 `col`、`pch` 等参数，请注意查看相应函数帮助：

- `ask`
- `fig, fin`
- `lheight`
- `mai, mar, mex, mfcol, mfrow, mfg`
- `new`
- `oma, omd, omi`
- `pin, plt, ps, pty`
- `usr`
- `xlog, ylog`

介绍完上面的参数之后，我们顺便提一下关于 `par()` 的常用技巧。本节开头提到过，这个函数会“永久性”改变作图设置，我们有时并不想要这种功能，特别是在一幅图作完之后到准备下一幅图时，我们可能希望之前的参数可以被“还原”回来。此时，我们就需要在一幅图开始之前先把作图参数保存到一个对象中，比如 `op = par()`；然后，我们可以 在作这幅图的过程中用 `par()` 函数任意更改设置以适合需要；作完这一幅图之后，我们再用 `par(op)` 语句把之前保存的参数设置“释放”出来。这样，中间过程对图形参数的更改就不再会影响到下一幅图。当然，也可以每作完一幅图都把图形设备关掉，然后再作下一幅图，这样也能达到目的，只是稍显麻烦而已，尤其是有时候对一幅图形反复重作、调整、比较，那时不断关闭、打开图形设备就显得更繁琐了。

至此，我们基本上已经介绍完所有常用的图形参数，但这些参数的作用没有必要全都烂熟于心；如果经常使用 R 基础作图函数的话，我们建议把常见参数常备手边，经常查阅[^r-graphical-parameters-cheatsheet]。

[^r-graphical-parameters-cheatsheet]: 这里是一个图形参数的可视化查询卡片 ：<https://tech.hohoweiya.xyz/R/r-graphical-parameters-cheatsheet.pdf>

## 作图元素

任何一幅统计图形都是由最基础的图形元素构成的，这些元素我们并不陌生，无非就是颜色、点、线（直线、曲线、线段甚至箭头）、矩形、任意多边形、文本以及图例。

R 提供了相应的一系列函数，用以向已有的图形中添加图形元素。事实上，R 的所有基础作图函数都可以分为两类，一类是高层函数（high-level），用以生成新的图形；另一类就是低层函数（low-level），指的正是绘制图形元素的这些基础函数。

本节所介绍的图形元素都是基础图形系统的元素，可以让读者了解如何从底层一步步构造一幅完整图形。当然，这并非对所有读者都有用。若想直接了解 R 高层作图函数，请阅读本书的第二部分。

### 颜色 {#sec:color}

默认情况下，R 中颜色的设置主要需要依靠的是 **grDevices** 包，提供了大量的颜色选择函数和生成函数，以及几种预先设置好的调色板（Palette），用以表现不同的主题。我们把 **grDevices** 包中所有关于颜色的函数大致分为三类：固定颜色选择函数、颜色生成和转换函数、特定颜色主题调色板。这些函数将在下面三小节中详细介绍。

#### 固定颜色选择函数 {#sec:palette .unnumbered}

固定颜色选择函数也就是 R 提供的自带固定种类的颜色，主要是函数 `colors()` 以及 `palette()`：

`colors(), colours()`
: 这两个函数完全一样，只是英文的两种不同拼写而已，它们不需要任何参数，会生成 657 种颜色名称，如：`"beige"`（米色）、 `"bisque"`（桔黄色）、`"chocolate"`（巧克力色）、`"cyan"`（青色）、`"gold"`（金黄色）、 `"ivory"`（象牙色）、`"lavender"`（浅紫色）等。下面的代码表示从 `colors()` 中随机抽取 20 种颜色（注意，`sample()` 是随机抽样函数，因此重复这个语句每次得到的结果可能会不一样，这是正常的）：

```{r random-colors, echo=2}
set.seed(714)
sample(colors(), 20)
```

有兴趣观看所有 657 种颜色的读者可以使用 **beginr** 包的 `beginr::plotcolors()` 函数，会得到两张颜色卡。一张是把这 657 种颜色按数字顺序排列，另一张是按颜色的相近程度排列。读者也可以试着运行下面的语句，其中 `pdf()` 函数的作用是打开一个作图设备，详情参见 \@ref(sec:device) 小节，可以把参数 `"colors-bar.pdf"` 替换为任意一个可以读写的路径[^windows-path]，条形图 `barplot()` 的说明参见 \@ref(sec:barplot) 小节。最后结果是在设定文件路径上获得一个 PDF 文件，展示所有颜色名称及其对应的颜色。

[^windows-path]: Windows 用户注意路径的写法，不能用通常的单反斜杠 \\，而应该把路径中的单反斜杠换成双反斜杠 \\\\ 或者用单斜杠 \/；如 `D:/colors.pdf` 或 `D:\\colors.pdf`

```{r color-bar,eval=FALSE, echo=TRUE}
pdf("colors-bar.pdf", height = 120)
par(mar = c(0, 10, 3, 0) + 0.1, yaxs = "i")
barplot(rep(1, length(colors())), col = rev(colors()), 
        names.arg = rev(colors()), horiz = TRUE, las = 1, xaxt = "n", 
        main = expression("Bars of colors in" ~ italic(colors())))
dev.off()
```

`palette()` 
: 调色板函数；用法 `palette(value)`，这个函数用来设置调色板或者获得调色板颜色值。注意，实际上这个函数的结果可能并非“固定”颜色，但是只要设定好了调色板，它的取值就不会再改变（直到下一次重新设定调色板）。如果不写任何参数，那么该函数返回当前的调色板设置，即一个包含当前调色板中所有颜色的向量；若参数长度为 1，则将当前调色板重新设置为以该参数为名称的调色板，目前这种参数只有 `"default"` 这一种，即设置为默认调色板：`palette("default")`；若参数为一个颜色向量，那么将当前调色板中的颜色更改为该参数表示的颜色。如下例：

```{r palette-demo-default, echo=TRUE}
palette() # 默认的调色板颜色
palette(colors()[1:10]) # 重新设置调色板为 colors() 的前 10 种颜色
palette() # 更改后的调色板颜色
palette("default") # 恢复默认调色板
```

这些颜色里，除了颜色的英文名称外，其它颜色都是由六个十六进制数字组成的，每两位数字（合起来取值从 0 到 255）分别表示红绿蓝（RGB 颜色）的比例。例如，当三原色完全混合时，生成的颜色是白色，用上述方法表示就是`"#FFFFFF"`。

调色板的好处在于，我们可以在 R 中使用一个整数来表示颜色，而这个整数对应的颜色就是调色板中相应位置的颜色，比如在某作图函数中调用参数 `col = 2` 表示取调色板中第 2 种颜色。 若整数值超过了调色板颜色向量的长度，那么 R 会自动取该整数除以调色板颜色向量长度的余数。

#### 颜色生成和转换函数 {.unnumbered}

R 提供了一系列利用颜色生成原理如 RGB 模型（红绿蓝三原色混合）、HSV 色
彩模型（色调、饱和度和纯度）、HCL 色彩模型（色调、色度和亮度）和灰色生成
模型等构造的颜色。颜色的构造原理比较复杂，超出了本书讨论范围，这里仅对相关函数的用法作介绍。 

`rgb()`
: 红绿蓝三原色混合，用法 `rgb(red, green, blue, alpha, names = NULL, maxColorValue = 1)`。其中，前四个参数都取值于区间 [0, maxColorValue]，`names` 参数用来指定生成颜色向量的名称。前三个参数值越大就说明对应的那种颜色所占成分越高。可能 `alpha` 我们不太熟悉，它指的是颜色的透明度：取 0 表示完全透明，取最大值表示完全不透明（默认）。透明度在统计图形中有着重要地位，因为它具有一个非常有用的性质------透明度可以叠加，即：两个或多个带有透明色的图形元素重叠在一起时，重叠部分的透明度会变小。这在某些统计图形中可以找到很好的应用，例如当散点图中点的数目过多而导致大量的点相互重叠时，我们可以使用透明色来看清图中的深层规律，其中一个直接的规律就是二维密度：点重叠越密集，则颜色越深（由于透明度的叠加），该处的密度值也越大。图 \@ref(fig:scatter-alpha) 给出了一个半透明色应用的示例。

`hsv()` 
: 用色调（Hue）、饱和度（Saturation）和纯度（Value）来构造颜色，用法 `hsv(h = 1, s = 1, v = 1, alpha)`。前三个参数分别对应色调、饱和度和纯度，取值于区间 $[0, 1]$。`alpha` 意思同上，但取值于区间 $[0, 1]$。

`hcl()` 
: 用色调（Hue）、色度（Chroma）和亮度（Luminance）构造颜色，用法为 `hcl(h = 0, c = 35, l = 85, alpha, fixup = TRUE)`。参数 h 取值于区间 $[0, 360]$，可以将它想象为一个角度：$0\,^{\circ}$ 表示红色，$120\,^{\circ}$ 表示绿色，$240\,^{\circ}$ 表示蓝色，中间的都是过渡色。参数 `c` 取值受 `h` 和 `l` 限制。参数 `l` 取值在区间 $[0, 100]$ 上，取值越大生成的颜色越亮。`alpha` 意思同上。`fixup` 表示是否修正生成的颜色值，之所以要修正，是因为有些搭配生成的 RGB 颜色 `(r, g, b)` 可能出现某一个元素超过 1 的情形。

`gray(), grey()` 
: 生成灰色系列。它们只有一个参数 `level`，表示灰度水平，取值在 0 到 1 之间，其中 0 表示纯黑色，而 1 表示纯白色。`level` 取一个向量则可以生成一系列灰色值，如下例：

```{r gray-demo, echo=TRUE}
gray(seq(0, 1, length = 5))
```

除了颜色生成函数之外，**grDevices** 包还提供了两种颜色转换函数，作用就是把一种颜色从一种颜色系统空间转移到另一种颜色系统空间中表示。这两个函数分别是：

`rgb2hsv()` 
: 将 RGB 颜色转换为 HSV 颜色，用法 `rgb2hsv(r, g = NULL, b = NULL, maxColorValue = 255)`。所有参数意思已经在上面的列表中解释过，只是要注意，当 `r` 是一个矩阵时，另外两个参数 `g` 和 `b` 就应省略不写。下例中我们将一个 $3\times4$ 的 RGB 颜色矩阵传入函数 `rgb2hsv()`，该函数会把每一列 RGB 颜色都转化为相应的 HSV 颜色。颜色矩阵的前三列分别是红、绿和蓝色，请观察和对比两种颜色系统的表示方法。

```{r rgb2hsv-demo, echo=TRUE}
# 赋值给变量 rgb.mat
(rgb.mat = matrix(c(255, 0, 0, 0, 255, 0, 0, 0, 255, 10, 100, 200), 
                   nrow = 3))
rgb2hsv(rgb.mat)
```

`col2rgb()` 
: 将任意一种 R 颜色值转换为 RGB 表示，用法 `col2rgb(col, alpha = FALSE)`。参数 `col` 的取值可以有三种形式：第一种是 `colors()` 函数中的任意一种颜色名称（字符串），第二种是如 `#rrggbb` 十六进制形式的 RGB 颜色表示，第三种是一个整数，即调色板中相应位置的颜色。

```{r col2rgb-demo, echo=TRUE}
col2rgb(4) # 调色板中第 4 种颜色默认是蓝色
col2rgb("yellow") # 黄色是由红绿混合得到的
col2rgb("#FF00FF") # 红蓝混合为紫色
```

#### 特定颜色主题调色板 {#subsec:palette .unnumbered}

对于一般人来说，前面介绍的颜色生成过程也许显得太复杂：除了美术和绘图专业人士，大部分人可能并不懂颜色的透明度、饱和度等概念，那么在配制大批量颜色的时候可能会比较迷惑。为此，R 提供了第三种选择，那就是特定颜色主题的调色板。这些调色板都用一系列渐变的颜色表现了特定的主题，例如彩虹颜色系列、白热化颜色系列、地形颜色系列等等。

`rainbow()`
: 顾名思义，就是用彩虹的颜色（“红橙黄绿青蓝紫”）来产生一系列颜色，用法 `rainbow(n, s = 1, v = 1, start = 0, end = max(1, n - 1)/n)`。参数 `n` 设定产生颜色的数目；参数 `s`、`v` 前文已经解释过；参数 `start` 和 `end` 设定彩虹颜色的一个子集，生成的颜色将从这个子集中选取，这个子集选取的大致分界线为：红色（red）为 0，黄色（yellow）为 1/6，绿色（green）为 2/6，青色（cyan）为 3/6，蓝色（blue）为 4/6，红紫色（magenta）为 5/6。

`heat.colors()`
: 从红色渐变到黄色再变到白色（以体现“高温”、“白热化”，读者可以在 R 中运行 `demo(image)` 并观察第二幅等高线图）。

`terrain.colors()`
: 从绿色渐变到黄色再到棕色最后到白色（这些颜色适合表示地理地形，读者可以运行 `demo(persp)` 并观察最后两幅关于火山的三维图形，以及运行 `demo(image)` 并观察第一幅等高线图）。

`topo.colors()`
: 从蓝色渐变到青色再到黄色最后到棕色。

`cm.colors()`
: 从青色渐变到白色再到粉红色（读者可以运行 `demo(image)` 并观察最后几幅颜色图）。

读者可以使用 **beginr** 包的 `beginr::plotcolorbar()` 函数来查看这几种调色板。

若想要获得更复杂更精细的颜色或调色板，不妨使用 **grDevices** 包中的颜色“插值”函数，如 `colorRamp()` 和 `colorRampPalette()` 函数，读者可以根据需要产生符合特定要求的调色板，以适应展示主题的需要，这里不详述这两个函数的使用方法。

对于缺乏耐心和兴趣去研究颜色的用户来说，附加包 **RColorBrewer** [@RColorBrewer] 也不失为一个好的选择。这个包提供了三类调色板，用户只需要指定调色板名称，就可以用包中的 `brewer.pal()` 函数生成颜色。这三类调色板包括：

- 连续型调色板（Sequential palettes）： 生成一系列连续渐变的颜色，通常用来标记连续型数值的大小。

- 极端化调色板（Diverging palettes）：生成用深色强调两端、浅色标示中部的系列颜色，可用来标记数据中的离群点。

- 离散型调色板（Qualitative palettes）：生成一系列彼此差异比较明显的颜色，通常用来标记分类数据。

每一类调色板下有若干种具体的实现，例如 `"Blues"` 是连续型调色板下的一种，用以蓝色主题的渐变颜色：

```{r ColorBrewer-Blues, echo=TRUE}
library(RColorBrewer)
brewer.pal(9, "Blues")
```

所有调色板名称及其展示参见图 \@ref(fig:ColorBrewer-all)。这些调色板并非一些简单的颜色组合，而是有一定科学根据的。例如，离散型调色板下的颜色对大多数人来说都有较好的区分度，甚至色盲也可以辨认其中不同类的颜色。如果用户对颜色选取拿捏不准，不妨用这个包来生成颜色。实际上，这个 R 包是一款叫 ColorBrewer 的产品[^ColorBrewer]的重新实现。

[^ColorBrewer]: <http://colorbrewer2.org/>

(ref:ColorBrewer-all) **RColorBrewer** 包中所有调色板颜色的演示：从上至下依次是连续型、极端化和离散型调色板

(ref:ColorBrewer-all-s) **RColorBrewer** 包中所有调色板颜色的演示

```{r ColorBrewer-all,fig.width=6, fig.height= 8, fig.scap="(ref:ColorBrewer-all-s)",fig.cap="(ref:ColorBrewer-all)", dev='tikz', fig.showtext = FALSE}
msg_graph("ColorBrewer-all")
```


#### 渐变色的简单原理及应用 {.unnumbered}

这里，我们特别用一小节来讲述“渐变色”，原因在于，在图形中应用渐变色，往往能让图形看起来更美观、避免单调的颜色在图形中显得突兀。

所谓“渐变”，也就是逐渐变化的意思，这种变化必然对应着某种单调或非单调的（可导）函数，这些函数用来控制颜色值逐步变化。最简单的例子莫过于线性函数：从一种颜色值到另一种颜色值线性变化。比如，我们在 `rgb()` 函数中用一元线性函数控制绿色在 $[0, 1]$ 上的取值，同时将红色和蓝色分别控制为 1 和 0， 那么我们将得到从纯红色到黄色的一个颜色渐变。如：

```{r gradient-color-demo, echo=TRUE}
(x = rgb(1, seq(0, 1, length = 30), 0))
```

读者不妨用 `barplot(rep(1, 30), col = x)` 看看效果。

显然，本小节的内容与前一小节所讲到的调色板是一致的，只不过调色板是预先配置好了的渐变色系列。我们在这里“重复”讲述渐变色的简单原理，目的是尽量让读者了解各种看起来比较神秘和高深的颜色使用招数的本质。

在本节的最后，我们要再次强调颜色的艺术性：根据不同的环境选用不同的颜色。虽然统计专业人士对绘画、美学可能不必深入了解，但是漂亮、适宜的统计图形总是受人欢迎的。笔者曾经在 [Ross Ihaka](https://www.stat.auckland.ac.nz/~ihaka/) 的个人主页上看到一个很好的例子，内容是展示全球气候变暖的温度随年份变化的折线图，这幅图使用了从黄色到红色的渐变色，而这样的颜色恰好能体现温度的灼热感。对于警示温室效应来说，这种渐变色是极为恰当的（思考一下我们平时作折线图是否会考虑这样的颜色搭配）；Ross Ihaka 并没有给出具体的代码，但通过前面的介绍和后面 \@ref(sec:polygon) 小节的阅读，相信读者一定可以自己动手作出类似的折线图。

这里我们也给出一段示例代码，核心部分在于控制多边形的 `col` 参数；事实上，这幅“折线图”是由多个颜色渐变的多边形重叠而成的，效果见图 \@ref(fig:grad-color)（图中数据为真实气温数据）。

```{r, results='asis'}
msg_code("grad-color")
```

(ref:grad-color) New Haven 地区的年均气温（1912~1971 年）：统计图形的应用应该根据数据和事实的环境灵活选取图形的样式。本图的数据为 1912 年至 1971 年 New Haven 地区的年均气温。数据来源：**datasets** 包中的 nhtemp

(ref:grad-color-s) New Haven 地区的年均气温（1912~1971 年）

```{r grad-color, fig.scap="(ref:grad-color-s)",fig.cap="(ref:grad-color)", dev='tikz', fig.showtext = FALSE}
msg_graph("grad-color")
```

### 点 {#sec:points}

关于点的设置，我们既可以在很多作图函数中用 `pch` 等参数实现，也可以用低层函数 `points()` 向已有图形中添加点来实现。后一种方法往往更灵活自由。`points()` 用法：

```{r points-usage, results='asis'}
usage2(usage(points.default, output = FALSE))
```

函数 `points()` 的参数如 `pch` 和 `col` 等在 \@ref(sec:par) 小节介绍 `par()` 函数时中有详细解释，但这两个函数中相同名称的参数最主要的一点区别就是：前者可以使用向量，而后者只能接受一个单值作为参数。此外还有一点细小差异在于参数 `bg`，它在函数 `points()` 中表示的是点的背景色而非图形的背景色。为了向图中添加一系列不同样式的点，我们可以使用向量作为 `points()` 的参数。

(ref:point-type-s) 点的类型：`pch` 参数取值从 0 到 25 及其它符号

(ref:point-type) 点的类型：`pch` 参数取值从 1 到 25 及其它符号。注意：21\~25 的点可以填充背景颜色

```{r point-type, fig.width=7, fig.height=3.5, out.width="80%", results='hide',fig.scap="(ref:point-type-s)",fig.cap="(ref:point-type)", dev='tikz', fig.showtext = FALSE}
msg_graph("point-type")
```

本节不再赘述参数的含义（读者可以自行查阅帮助），但有三点仍需特别说明一下：

`lwd`:
: 这是设定线条宽度的。对于点来说，这个参数同样可以设置点的边缘“线条”宽度。

`pch`:
: 取值从 21\~25 的点可以填充背景颜色。注意观察，图 \@ref(fig:point-type) 中 21\~25 的点边缘线颜色和背景色是不同的，而在 25 之后的点则采用了文本符号作为参数 `pch` 的值。图 \@ref(fig:point-type) 中也有几对形状一样的点，但是它们实质上是不一样的，例如 0、15 和 22 对应的点都是正方形，但前二者分别是空心正方形和实心正方形，且都不可填充背景，而 22 对应的点是空心正方形，可以填充背景。同样可以接受字符作为参数值，而不仅仅是数字。

一次性作出不同样式的点对于图形阅读和统计分析来说是很有利的，比如有时候我们可以把样本根据某一特征分为几组，对每一组子样本都采用不同的样式作点图，那么我们或许可以从图中点的散布情况发现组间的差异特征。图 \@ref(fig:point-iris) 给出了一个鸢尾花散点图（数据见表 \@ref(tab:tab-iris)）的示例（注意向量的使用），很明显，setosa 这一类花的型号较小，因为它们都处于散点图的左下角。 

```{r, results='asis'}
msg_code("point-iris")
```

(ref:point-iris) 鸢尾花的花瓣长宽散点图：我们可以给每一种鸢尾花标记不同类型的点和颜色，这样可以帮助我们更清楚地区分鸢尾花类型

(ref:point-iris-s) 鸢尾花的花瓣长宽散点图

```{r point-iris, out.width="80%", fig.scap="(ref:point-iris-s)",fig.cap="(ref:point-iris)", dev='tikz', fig.showtext = FALSE}
msg_graph("point-iris")
```

图 \@ref(fig:point-random) 为本书的一例“彩蛋”：基于随机性的图形可能会具有某种艺术性。这里仅仅展示了四幅可能的输出，其它更多可能的结果可以观看演示 `demo("pointArts", package = "MSG")`[^art-of-points-in-r]。若读者感兴趣，甚至可以用 R 为自己生成一幅桌面背景图片，制作方法在前面链接中有介绍。

[^art-of-points-in-r]:  <https://yihui.org/cn/2010/08/art-of-points-in-r/>

```{r point-random, fig.scap="(ref:point-random-s)",fig.cap="(ref:point-random)"}
msg_graph("point-random")
```

(ref:point-random-s) 点的随机艺术作品

(ref:point-random) 点的随机艺术作品：随机生成点的大小、颜色和位置，分别用空心点和实心点画图

### 曲线、直线、线段、X-样条 {#sec:lines}

在 \@ref(sec:par) 小节介绍函数 `par()` 时，我们提到了关于线条的一些参数设置，例如 `lwd` 和 `lty` 等。类似地，我们可以用函数 `lines()` 来向图中添加曲线（这里所说的曲线本质上是一些线段的连接，并非光滑的曲线）；下面主要补充说明一下关于线条样式 `lty` 的设定。

R 中可以实现几乎无数种线条样式，因为它的 `lty` 参数相当灵活，除了取值 0\~6 之外，可以根据一个十六进制的数字串（位数必须是偶数位，且非零）来设定线条的虚实，具体原理是这样的：数字串的奇数位上的数字表示画相应长度的实线，偶数位上的数字则表示空缺相应的长度，这样就构成了一条虚线。例如，`"A5"` 表示先画 11 单位长的实线，再接着画 5 单位长的空白，紧接着又画 11 单位长的实线，……，就这样重复下去，完成一条虚线；同理，`"711911"` 表示7 单位长实线、1 单位长空白、1 单位长实线、9 单位长空白、1 单位长实线、1 单位长空白。这个十六进制的数字串的最长长度限制为 8 位。

当设定 `type = "h"` 时，`col` 参数可以使用向量，此时各条竖线都将使用不同的颜色；除此情况之外，若其它参数使用了向量，那么只有向量的第一个元素会被使用，其它元素都将被忽略掉。

关于直线，我们在平面坐标系中只需要确定两个因素就可以确定它的位置：斜率和截距。函数 `abline()` 就是用来添加直线的，参数同样可以使用向量（这一点在低层函数中几乎普遍适用，下文不再重复说明）。函数用法如下：

```{r abline-usage, results='asis'}
usage2(usage(abline, output = FALSE))
```

\noindent 参数含义：

`a`:
: 截距。

`b`:
: 斜率。

`h`: 
: 画水平线时的纵轴值。

`v`:
: 画垂直线时的横轴值。

`reg`:
: 一个能用函数 `coef()` 提取系数（包含斜率和截距）的 R 对象，典型的就是用线性模型（回归）生成的对象，系数是一个长度为 2 的向量，分别为截距和斜率。

`...`:
: 可以传入其它参数（比如 `lty`、`col` 等）。

线段可以用函数 `segments()` 生成，用法如下：

```{r segments-usage, results='asis'}
usage2(usage(segments, output = FALSE))
```

前四个参数表示线段的起点和终点坐标，后面的参数相信读者也都已经熟悉。


下面的代码演示了如何向图形中添加曲线、直线、线段等要素（图 \@ref(fig:lines-demo)）：

```{r, results='asis'}
msg_code("lines-demo")
```

(ref:lines-demo) 曲线、直线、直线段、箭头的展示说明

```{r lines-demo, fig.cap="(ref:lines-demo)", dev='tikz', fig.showtext = FALSE}
msg_graph("lines-demo")
```

下面我们再介绍一下一种特殊的曲线——X-样条（X-spline）。

样条是用光滑曲线连接若干数据点的曲线。它与前面提到的曲线 `lines()` 的区别在于数据点之间的连接线。样条函数用法如下：

```{r xspline-usage, results='asis'}
usage2(usage(xspline, output = FALSE))
```

`x`、`y`:
: 点的位置。

`shape`:
: 样条的形状，取值在 $[-1, 1]$ 之间。当取值为负数时，曲线穿过给定的点，负值绝对值越小则曲线的角度越尖锐，反之角度越圆滑；取值为正数时，曲线脱离给定的点，正值越小越靠近给定点。

`open`:
: 决定是否样条曲线封闭。

`repEnds`:
: 逻辑值，当样条曲线不封闭时，该参数决定是否重复使用端点上的点。

`draw`:
: 决定是否画线。若为 `FALSE`，则仅仅计算曲线的坐标位置而不画线。

`border`:
: 曲线的颜色。

`col`:
: 封闭曲线的填充颜色。

图 \@ref(fig:xspline-demo) 为各种形状的 X-样条，注意观察 `shape` 参数与曲线形状的对应关系。

(ref:xspline-demo-s) X-样条各种形状的展示

(ref:xspline-demo) X-样条各种形状的展示：观察 `shape` 参数的取值（图中标注的数字）与样条形状的对应关系

```{r xspline-demo,results='hide',fig.scap="(ref:xspline-demo-s)",fig.cap="(ref:xspline-demo)", dev='tikz', fig.showtext = FALSE}
msg_graph("xspline-demo")
```

### 箭头、误差线 {#sec:arrow}

图 \@ref(fig:lines-demo) 除了展示曲线、直线和线段外，还展示了箭头的示例。箭头的绘制方法与线段类似。之所以在此单独介绍，是因为一个特殊的原因：误差线常常是用箭头函数绘制的。

绘制箭头的函数是 `arrows()`，用法如下：

```{r arrows-usage, results='asis'}
usage2(usage(arrows, output = FALSE))
```

类似于线段，前四个参数表示箭头的起点和终点坐标。其它参数简介如下：

`length`:
: 箭头尖上短线的长度（单位：英寸）。若设置为 0，那么将不会画出箭头（只有箭头线的主体，即一条线段）。

`angle`:
: 箭头尖短线的角度（默认为 $30\,^{\circ}$）。

`code`:
: 箭头的样式（整数 1~3 分别表示尾部箭头、首部箭头和两端都带箭头）。

除了绘制常见箭头外，这个函数常用来绘制误差线：只需将箭头尖短线的角度设置为 $90\,^{\circ}$ 即可。下面的代码将绘制一个带有误差线的条形图（见图 \@ref(fig:error-bars)）：

```{r errorbar, echo=TRUE, eval=FALSE, fig.cap="", fig.scap=""}
y = c(runif (20), c(.43, .54), c(.6, runif (9, .3, .4)), 
       c(runif (6, .5, .6) - .12, runif (4, .15, .22) + .12)) - .2
x = factor(rep(LETTERS[1:4], c(20, 2, 10, 10)))
m = tapply(y, x, mean)
mid = barplot(m, col = 1:4, ylim = c(0, .4))[, 1]
s = 2 * tapply(y, x, sd) / sqrt(table(x))
arrows(mid, m - s, mid, m + s, code = 2, col = 1:4, 
       angle = 90, length = .15)
```

\@ref(subsec:grad-desc) 小节给出了一个往图形中添加箭头的例子。 关于误差线的讨论，见 \@ref(sec:stat-principle) 节。

### 矩形、多边形 {#sec:polygon}

R 中绘制多边形也是很方便的，主要使用 `polygon()` 函数。多边形的主要特征在于增加了一些填充选项，比如颜色填充，或者用阴影线填充。关于颜色、线条样式的设置就不再重复说明。矩形是多边形的特例， R 提供了专门的函数 `rect()` 来绘制它。矩形和多边形的用法如下：

```{r polygon-usage, results='asis'}
usage2(usage(rect, output = FALSE))
usage2(usage(polygon, output = FALSE))
```

`xleft`、`ybottom`、`xright`、`ytop`:
: 分别指定左下角和右上角的坐标，用以确定矩形的位置。

`x`、`y`:
: 给出一系列坐标点，用以围成一个多边形。

`density`:
: 设置阴影线的填充密度（每英寸填充多少条线）。如果设置了一个正值，那么颜色填充参数 `col` 将被用到阴影线上；只有设置为负数或 `NA` 或 `NULL` 时，`col` 才可以填充整个区块颜色。

`angle`:
: 设置填充线条的角度。

`col`:
: 设置填充颜色。

`border`:
: 设置边框颜色。若设置为 `FALSE` 或 `NA`，那么边框线将被省略。

绘制多边形时要清楚它的过程：线条会随着横纵坐标逐点延伸，也就是画普通折线的过程，当走到最后一点时，就会重新延伸回第一点，这就是绘制多边形的基本原理。

一般来说，大部分作图函数对于缺失数据都会默认省略不画，不会对图形造成什么影响，而对于多边形函数，数据中的缺失将构成“分界点”，用以分隔缺失点两端的点群。因此，若数据含缺失值，那么会有多个多边形被作出来。这一点性质对与多边形的灵活运用也是很重要的，我们有时可以故意设置缺失值，用以将图形分割为不同的区域。关于这一点，下面我们用一个比较巧妙的例子来说明具体用法。

(ref:polygon-kaleidoscope) 用多边形生成的“万花筒”：若干彩色三角形（或者称之为“千纸鹤图”？）

(ref:polygon-kaleidoscope-s) 用多边形生成的“万花筒”

```{r polygon-kaleidoscope,fig.scap="(ref:polygon-kaleidoscope-s)",fig.cap="(ref:polygon-kaleidoscope)",results='hide'}
msg_graph("polygon-kaleidoscope")
```

图 \@ref(fig:polygon-kaleidoscope) 是利用含有缺失值的数据画出来的多边形，它看起来与万花筒图案有些相似（本例为“彩蛋”）。这幅图的生成过程是：随机生成 3 个标准正态分布随机数，然后插入一个缺失值 `NA`，下一次再以上一批随机数的最后一个为均值生成 3 个随机数，依此类推生成若干组“三个随机数加上一个 `NA`”这样的数据，这样最后画多边形的时候，得到的就是若干个独立的三角形。我们将这一组三角形分别向右、向上和向下平移，得到四组三角形，也就是不太精确地模仿了万花筒的原理。该演示收录在 **MSG** 包中，读者可用 `demo("kaleidoscope", package = "MSG")` 查看源代码。


关于多边形和矩形，我们用一个比较巧妙的例子来说明具体用法。代码如下，效果参见图 \@ref(fig:polygon-demo)。

```{r, results='asis'}
msg_code("polygon-demo")
```


(ref:polygon-demo-s) 多边形和矩形结合使用的一个巧妙图示

(ref:polygon-demo) 多边形和矩形结合使用的一个巧妙图示：将 0 上下的数值分别用不同颜色填充。本图也可以利用 `clip()` 函数更方便地完成，请读者自行查阅帮助

```{r polygon-demo, fig.scap="(ref:polygon-demo-s)",fig.cap="(ref:polygon-demo)", dev='tikz', fig.showtext = FALSE}
msg_graph("polygon-demo")
```

这幅图的目的在于只填充 y 值在 0 以上的部分，而将 0 以下的部分留空。采取的手段是：先用多边形整体填充颜色，然后根据当前图形的坐标范围（用 `par("usr")` 获得，或者等价使用 `par()$usr`。参见 \@ref(sec:par) 小节）画一个白色的矩形覆盖 0 以下的图形部分，此时下面部分的线条也被覆盖了，因此接着我们必须再次画线，将所有线条补充完整，最后，添加一条高度为 0 的水平线，即完成本图。 

最后要说明，其实还有一个特殊的“矩形”，那就是整幅图形的边框，它可以用 `box()` 函数来完成。我们可以不使用任何参数以添加默认的边框，也可以调整一些参数画出不同样式的方框（如虚线框等），具体参见 `?box`。

### 网格线 {#sec:grid}

有时为了方便图形阅读者知道图中元素的更精确的位置，我们可以用添加背景网格线的办法来辅助读者的视线对齐坐标轴。函数 `grid()` 所实现的就是这一个功能，它的用法较简单：

```{r grid-usage, results='asis'}
usage2(usage(grid, output = FALSE))
```

可以看到，这个函数已经使用了一些默认的参数设置，例如将网格线的颜色设置为浅灰色，线条样式设置为点线，这是一种比较美观的设置，让网格线既不显得太突兀，又能达到辅助的效果。一般情况下，我们可以直接使用不带参数的 `grid()` 函数添加网格。

\noindent 参数含义：

`nx` 和 `ny`:
: 分别表示横纵轴上网格线的条数。

`equilogs`:
: 当坐标取了对数之后，是依然使用等距的网格线（`TRUE`）还是根据对数函数使用不等距的网格线（`FALSE`）。

细心的读者也许能发现，其实前面讲到的内容中已经有两处可以实现“网格线”的功能，第一处是 `par()` 函数中的 `tcl`（或 `tck`），将坐标轴的刻度线长度设置为图形的宽高就可以构成一种粗略的网格；第二处是 `abline()` 函数，使用参数 `h` 和 `v` 即可实现更细致的网格线。

### 标题、任意文本、周边文本 {#sec:text}

本节中的文本以及下一节中的图例都是用来辅助解释图形的信息。图形中的所有文本可以分为三类：标题（主副标题和坐标轴标题）、任意文本和图形周边文本。`title()` 函数用来添加标题，`text()` 函数用来向图形中任意位置添加文本，`mtext()` 函数用来向图的四条边上添加文本。用法如下：

```{r text-usage1, results = "asis"}
usage2(usage(title, output = FALSE))

```
```{r text-usage, results = "asis"}
usage2(usage(text.default, output = FALSE))
usage2(usage(mtext, output = FALSE))
```
\noindent 参数含义：

`main`、`sub`、`xlab`、`ylab`:
: 主、副、x 轴、y 轴标题的字符串。

`line`:
: 设置一个距离图形边缘的行数（即：文本与图形边缘的距离为 `line` $\times$ 行高）。

`outer`:
: 是否将文本放在外边界中（参见 \@ref(sec:par) 小节的说明）。

`labels`:
: 欲添加的文本（对应横纵坐标的设置，可以是字符串向量），若不指定本参数，那么默认将以数字 `1:length(x)` 作为文本标记添加到图中。

`adj`:
: 与 `par()` 中说明相同。

`pos`:
: 取值整数 1\~4，分别表示文本的位置在坐标点的下、左、上、右方。注意，它会覆盖参数 `adj` 的设置。

`offset`:
: 根据 `pos` 参数的取值，将文本向相应的方向移动一定比例的距离。

`side`:
: 取值为整数 1\~4，分别把文本添加在图形的下、左、上、右边；

`vfont`:
: 用 Hershey 矢量字体来设置文本的字体式样，取值长度为 2 的向量，第一个元素指定字体（Typeface），第二个元素指定式样（Style）。

关于字体和式样的搭配种类，请查看帮助 `?Hershey`。使用 Hershey 矢量字体的优势在于：

- Hershey 字体会产生更好的输出，特别在计算机屏幕上，或者用于旋转以及小字体时
- Hershey 字体提供一些标准字体库没有的字体。如提供星座记号，地图符号和天文学符号
- Hershey 字体提供西里尔字符（cyrillic）和日语字符（假名和日本汉字）

此外，等高线图中通常使用 Hershey 矢量字体以使等高线上的文本更清晰好看（该字体的一个缺陷是不能用在数学公式中）。

字体设置和搭配的内容体系比较庞大，本书限于篇幅无法展开介绍，感兴趣的读者请仔细阅读帮助文档。若无特别设定，这些文本的样式都将根据当前的函数 `par()` 结果来设置，比如颜色、字体等。

(ref:text) 添加标题、任意文本和周边文本的一个演示

```{r text,fig.cap="(ref:text)"}
msg_graph("text")
```

### 图例 {#sec:legend}

众所周知，图例是很重要的辅助信息，告诉图形使用者图中各组不同样式的元素分别代表何种对象。R 语言添加图例的函数是 `legend()` ，用法如下：

```{r legend-usage, results = "asis"}
usage2(usage(legend, output = FALSE))
```

它的参数比较多，但实际应用中通常仅仅用到其中少数几个：


`x` 和 `y`:
: 图例的坐标位置（左上角顶点的坐标）。

`legend`:
: 通常为一个字符向量，表示图例中的文字。

`fill`:
: 指定一个与图例字符向量对应的颜色向量，用以在文本左边绘制一个颜色填充方块。

`col`:
: 设置图例中点和线的颜色。

`lty`、`lwd` 和 `pch`:
: 指定图例中点线的样式。

`angle` 和 `density`:
: 效果类似于 `fill` 参数，只是换成指定角度和密度的阴影线填充方块。

`bty`:
: 设置图例框的样式，很类似 `par()` 中的同名参数。

`title`: 
: 设定图例的标题。

剩余参数用来设置更细微的地方，不太常用。

从以上几节对图形元素的介绍可以看出，R 可以设置极其细微的元素特征。当然，读者不必过于细究所有的参数。对于大多数函数来说，都只有两三个核心参数，比如，坐标位置向量是几乎所有函数的共同核心参数，而 `legend()` 函数的主要参数除了坐标位置之外还有字符向量 `legend`。对于其它参数，请在使用时即时查阅即可。

关于网格线、文本和图例，图 \@ref(fig:text) 给出了它们的示例。 

### 坐标轴 {#sec:axis}

坐标轴是图中元素所代表数值大小的参照物，因此它在图形中的作用也很重要，特别是有时候我们需要对坐标轴做一定的特殊设置，比如作一幅双坐标轴的图形，或者在坐标轴标记中使用特殊的文本，那么就必须使用 `axis()` 函数来辅助完成对坐标轴的设置和调整。该函数的用法如下：

```{r axis-usage, results='asis'}
usage2(usage(axis, output = FALSE))
```

\noindent 参数含义：

`side`:
: 与 `mtext()` 函数中的参数意思相类似，表示将坐标轴画在哪条边上。事实上，通过前面一些图形元素参数的讲解，读者应该能意识到，R 中上下左右方向的顺序一般都是“下、左、上、右”，分别用 1、2、3、4 表示。

`at`:
: 表示在什么位置画坐标轴标记线。

`labels`：
: 指定坐标轴刻度标记的字符。

@Murrell05 中第 3.4.5 小节举了一个双坐标轴图形的例子，用左右两边的纵轴分别表示摄氏和华氏的温度，即：对于图中同一点，既可以对照左边看摄氏度，也可以对照右边看华氏度；这就是双坐标轴的用途。此处我们不妨举一个类似的例子，来说明 `axis()` 函数的功能。

```{r tab-axis}
data(Export.USCN, package = "MSG")
kable2(x = Export.USCN, "1999 至 2004 年中美两国的出口贸易总额数据", only_head = FALSE)
```

表 \@ref(tab:tab-axis) 是一组 1999\~2004 年中美两国的出口贸易总额数据[^axis-demo]。我们将这组数据展示在图 \@ref(fig:axis-demo)。其中，`axis()` 函数主要作用在于两个地方：

[^axis-demo]: 本例中使用的数据来源为：汇率数据来自联合国统计署网站 <https://unstats.un.org>，1999\~2004 年人民币和美元的平均汇率稳定在 8.27，出口额年度数据来自 WTO 网站：<https://data.wto.org>。

1.横轴的刻度标记。注意这些刻度标记与我们平时看到的标记有所不同，主要是这一系列标记都是两行文本，原因就在于 `labels` 参数中使用了换行符，对 C 语言比较熟悉的读者对此不会感到陌生。这里第一行是年份，第二行说明了国家：CN 表示中国，US 表示美国。

2.图的右边多了一根坐标轴，左边的纵轴表示出口额按美元计价（单位：$10^{16}$ 美元，出口额数值太大，因此采用较大的单位），右边表示同样的出口额用人民币计价（例如右边轴上 400 人民币对应左边 $400/8.27\approx48.4$ 美元），同一个数值在图中既可以从左边观察美元金额，又可以从右边观察人民币金额。

图 \@ref(fig:axis-demo) 的作图代码为：

```{r, results='asis'}
msg_code("axis-demo")
```


(ref:axis-demo) 双坐标轴图示：中美两国 1999\~2004 年出口额，分别以美元和人民币表示。注意图中 x 轴标签文本是如何换行的

(ref:axis-demo-s) 中美出口额双坐标轴图示

```{r axis-demo, fig.width=7, fig.height=4, out.width="80%", fig.scap="(ref:axis-demo-s)",fig.cap="(ref:axis-demo)", dev='tikz', fig.showtext = FALSE}
msg_graph("axis-demo")
```

这组数据可以通过以下代码获取：

```{r Export-data, eval=FALSE, echo=TRUE}
data(Export.USCN, package = "MSG")
Export.USCN
```

### 数学公式 {#sec:plotmath}

由于统计理论中经常需要用到数学符号，所以向统计图形中添加一些数学说明不仅会使得图形看起来更专业，对图形背后的理论也是一种重要补充。

R 的 **grDevices** 包\index{grDevices 包}提供了一系列数学公式的表达符号，例如运算符（加、减、乘、除、乘方、开方等）、比较符（等号、不等号、大于、小于号等）、微积分符号、希腊字母（大小写 $\alpha$ 至 $\omega$）、上标下标等等。这些数学符号的使用与 $\LaTeX$ 数学公式非常类似，因此如果读者对 $\LaTeX$ 公式比较熟悉的话，用起 R 中的数学表达式来也会很顺手。

如果想向图中添加数学表达式的文本标签，只需要将文本设置为表达式（expression）的类型即可。 图 \@ref(fig:plotmath) 展示了向正态曲线上添加正态分布密度函数表达式的方法。另外，我们也可以设置符号的外形，如斜体、粗体等。详情参见 `?plotmath` 或者运行代码 `demo(plotmath)` 观看 R 提供的数学公式演示。


```{r plotmath1, results='asis'}
msg_code("plotmath")
```

(ref:plotmath) 正态分布密度函数公式的表示

```{r plotmath,echo=FALSE,fig.width=4.8, fig.height=3.6, out.width="80%", fig.cap="(ref:plotmath)",dev='tikz',fig.process=to_png,fig.showtext=FALSE,small.mar=FALSE}
msg_graph("plotmath-tikz")
```

注意：本书中的图形大多数由 **tikzDevice** 包 [@tikzDevice] 生成，其中的数学公式为原始 $\LaTeX$ 代码，其质量比 R 自身的数学公式质量高很多，在这里不作详细介绍。

<!--
### 字体

Base R 绘图系统不太容易独立地设置坐标轴标签和刻度标签的字体

(ref:font-in-plot-s) 在 Base R 绘图系统中设置中英文字体

(ref:font-in-plot) 在 Base R 绘图系统中设置中英文字体，当 `family = "serif"` 在 Windows 环境下会调用 TimesNewRomanPSMT 字体，在 Linux 系统上调用 NimbusRomNo9L-Regu 字体，设置 `family = "sans"` 在 Windows 平台上会调用 ArialMT 字体，更多说明见 <https://github.com/r-lib/systemfonts#system-defaults>

```{r font-in-plot,fig.cap="(ref:font-in-plot)",fig.scap="(ref:font-in-plot-s)",fig.asp=0.5}
layout(matrix(c(1, 2), nrow = 1, byrow = TRUE), c(1, 1))
par(family = "serif", mar = c(4.1, 4.1, 0.5, 0.5)) 
plot(pressure, family = "sans")
par(family = "sans") 
plot(pressure, xlab = "温度", ylab = "压力", family = "GB1")
text(x = 50, y = 600, labels = "散点图", family = "GB1")
```

-->

## 页面布局 {#sec:multipage}

有时候，我们需要将多幅图形放在同一页图中，以便对这些图形作出对比，或者使图形的排列更加美观。这种情况下，我们至少可以有三种选择。

### 设置图形参数 

在前面 \@ref(sec:par) 小节，我们曾经讲到过 `mfrow` 和 `mfcol` 两个参数。如果我们在 `par()` 函数中给二者之一提供一个长度为 2 的向量，那么接下来的图形就会按照这两个参数所设定的行数和列数依次生成图形。本书的图形中有很多用到过这两个参数，如图 \@ref(fig:plot-type)、\@ref(fig:point-random) 等，另外有一些统计图形函数也利用了这两个参数设置它们的图形版面，如四瓣图、条件分割图等。

这两个参数的限制在于：它们只能将图形区域拆分为网格状，每一格的长和宽都分别必须相等，而且每一格中必须有一幅图形，不能实现一幅图形占据多格的功能。下面的两个函数则灵活许多。

### 设置图形版面

R 提供了 `layout()`\index{layout()}函数作为设置图形版面拆分的工具，其用法如下：

```{r layout-usage, results = "asis"}
usage2(usage(layout, output = FALSE))
usage2(usage(layout.show, output = FALSE))
```

\noindent 参数含义：

`mat`:
: 一个矩阵，提供了作图的顺序以及图形版面的安排。

`widths` 和 `heights`:
: 提供了各个矩形作图区域的长和宽的比例。

`respect`:
: 控制着各图形内的横纵轴刻度长度的比例尺是否一样。

`n`:
: 欲显示的区域的序号。

`mat` 矩阵中的元素为数字 1 到 n，矩阵行列中数字的顺序和图形方格的顺序是一样的。图 \@ref(fig:layout) 解释了这种顺序，该图的矩阵为：

```{r layout-matrix, echo=TRUE}
matrix(c(1, 2, 1, 3), 2)
```

\noindent 这种设置使第 1 幅图占据了 `(1, 1)` 和 `(1, 2)` 的位置，接下来第 2、3 幅图分别在 `(2, 1)` 和 `(2, 2)` 的位置；加上长度和宽度的设置，便产生了图 \@ref(fig:layout) 的效果。

(ref:layout) 函数 `layout()` 的版面设置示意图

```{r layout,fig.width=3, fig.height=1, out.width="80%", fig.cap="(ref:layout)", dev='tikz',fig.showtext=FALSE}
msg_graph("layout")
```

图 \@ref(fig:layout-margin) 是 `layout()` 函数的示例，展示了二元变量的边际分布以及回归直线。

(ref:layout-margin) 回归模型中边际分布的展示：左下方图中展示了散点图和回归直线，上方和右方的直方图分别展示 了自变量和因变量的密度分布

(ref:layout-margin-s) 回归模型中边际分布的展示

```{r layout-margin,fig.cap="(ref:layout-margin)",fig.scap="(ref:layout-margin-s)",results='hide', dev='tikz', fig.showtext = FALSE}
msg_graph("layout-margin")
```

### 拆分设备屏幕

R 中还有另外一种拆分屏幕的方法，即 `split.screen()`\index{split.screen()}。这种方法比前两种方法更灵活，它不仅可以像前两种方法一样设定将作图区域拆分为若干行列，也可以随意指定作图区域在屏幕上的位置。该函数及相关函数用法如下： 

```{r split-screen-usage, results = "asis"}
usage2(usage(split.screen, output = FALSE))
usage2(usage(screen, output = FALSE))
usage2(usage(erase.screen, output = FALSE))
usage2(usage(close.screen, output = FALSE))
```

拆分后的屏幕由若干个区域（即 screen）构成，每个区域有一个编号。我们可以用函数 `screen()` 指定要作图的区域号，或者用 `erase.screen()` 擦除该区域的图形，而 `split.screen()` 的用法主要由 `figs` 参数控制——该参数既可以取值为一个长度为 2 的向量（指定行列的数目），也可以是一个 4 列的数值矩阵，用来指定图形区域的坐标位置。后一种用法比较灵活，它可以将图形作在屏幕的任意位置上，这里的 4 列矩阵分别给定区域横坐标的左和右以及纵坐标的下和上的位置，即给定了区域左下角和右上角的坐标，这样就可以划分出一块矩形作图区域来。注意这里的坐标值应该在 `[0, 1]` 范围内，整个屏幕左下角坐标为 `(0, 0)`，右上角坐标为 `(1, 1)`。

图 \@ref(fig:split-screen) 给出了用矩阵指定作图区域位置的示例，该矩阵的取值为：

```{r split-matrix, echo=TRUE}
(mat_scr = matrix(c(
  0  , 0.1, 0.4, 0.3,
  0.5, 0.8, 0.9, 1,
  0  , 0.2, 0.3, 0.5,
  0.4, 0.7, 0.8, 1),
  4, 4))
```

矩阵一共四行，因此制定了四个屏幕作图区域，四列给定了区域的位置。例如，第 1 个区域的位置在点 `(0.0, 0.0)` 与点 `(0.5, 0.4)` 之间。该示例中，整个屏幕中划分出了 4 块有重叠的区域，并分别画出了 4 幅散点图。

绘制该图的完整代码为：

```{r, results='asis'}
msg_code("split-screen")
```

(ref:split-screen) 拆分作图设备屏幕区域的示例：本图展示了如何用一个矩阵参数控制作图区域在屏幕上的位置。

(ref:split-screen-s) 拆分作图设备屏幕区域的示例

```{r split-screen, fig.cap="(ref:split-screen)",fig.scap="(ref:split-screen-s)",results='hide'}
msg_graph("split-screen")
```

拆分屏幕区域方法的灵活性还在于，它可以在拆分的区域中继续拆分（类似于“递归”的做法），而前两节中提到的办法是无法做到这一点的。因此，三种方法中，这种方法的功能是最强大的。大多数情况下，我们其实用不着如此灵活的定制方法，网格式拆分已经足够使用。

```{r hack-split-screen,echo=FALSE}
## this is to get rid of a weird error
assign("par.list", setdiff(get("par.list", graphics:::.SSenv), "mfg"), graphics:::.SSenv)
```

## 交互操作 {#sec:interaction}

R 的图形设备可以支持简单的交互式操作，包括支持对鼠标和键盘输入的响应等，这主要由 **graphics** 和 **grDevices** 包中的函数来完成，本节逐一介绍。

### 获取鼠标位置的坐标

**graphics** 包中的函数 `locator()` 可以获取当前鼠标在图形坐标系统中的位置坐标，其用法为：

```{r locator-usage, results = "asis"}
usage2(usage(locator, output = FALSE))
```

当我们在图形窗口中创建了一幅图形后，我们可以调用该函数并通过点击鼠标获得坐标。参数 `n` 表示鼠标点击的次数；`type` 为点击鼠标之后生成的图形类型，可以边点鼠标边画点或画线；后面的参数为一些图形参数，设定点或线的样式。

该函数在点击鼠标事件结束之后会返回一个包含坐标数据的列表，列表中 x 和 y 分别表示横坐标和纵坐标的位置。如下例： 

```{r locator-example,eval=FALSE, echo=TRUE}
plot(1)
# 任意点击三下鼠标
locator(3)
# 返回坐标（结果取决于用户点击的位置）
```

```
## $x
## [1] 0.6121417 0.8046955 1.2561452
## $y
## [1] 0.9562884 0.8710420 1.1648702
```

借助 `locator()` 返回的坐标数据，我们可以更方便地向图中添加一些图形元素，尤其是图例。因为 R 的图形设备大多都不支持图形元素的鼠标拖拽，所以事先使用 `locator()` 在图上“探探路”对画图还是很有帮助的。

### 识别鼠标附近的数据

**graphics** 包中的函数 `identify()` 可以通过鼠标点击一幅散点图识别鼠标周围的数据点，并且可以给辨识出的数据添加标签，其默认用法如下：

```{r identify-usage, results='asis'}
usage2(usage(identify, "default", output = FALSE))
```

\noindent 参数含义：

`x` 和 `y`:
: 散点图的原始数据，以便鼠标位置坐标与原始数据进行距离匹配。

`labels`:
: 数据的标签，默认用数据的序号 1、2、3……

当数据的散点图呈现出异常现象时，如存在离群点等等，我们可以很方便地通过 `identify()` 函数找出该数据的名称或者序号。

### 响应鼠标键盘的动作

**grDevices** 包中的函数 `getGraphicsEvent()` 提供了更灵活的交互，它可以捕获三种鼠标事件（鼠标按下、鼠标移动和鼠标弹起）和一种键盘事件（键盘输入）。用法如下：

```{r getGraphicsEvent-usage, results='asis'}
usage2(usage(getGraphicsEvent, output = FALSE))
```

后面六个参数分别定义了鼠标和键盘事件所对应的行为（通过给定函数实现），具体解释和示例请参见其帮助文件，这里我们只是给出一个例子说明：

(ref:graphicsEvent) 鼠标在图形窗口中移动的效果图

```{r graphicsEvent,out.width="80%", fig.cap="(ref:graphicsEvent)",results='hide'}
msg_graph("graphicsEvent")
```

图 \@ref(fig:graphicsEvent) 演示了鼠标移动的效果：我们在黑色背景的窗口中画了一批数据点，然后通过鼠标的移动在鼠标周围生成一个矩形框，框内的点变成黄色且放大的样式，而框外的点为红色的小点。随着鼠标的移动，矩形框也会在屏幕上移动，从而会框住不同的点。


事实上当今已经有很多类似的交互式图形系统，例如 Java 的图形系统、OpenGL 等，R 中也有相应的基于这些系统的函数包如 **iplots** [@iplots]、 **rgl** [@rgl] 等。感兴趣的读者可以查看这些附加包的帮助信息，去研究这些图形系统。


## 图形设备 {#sec:device}

利用 **grDevices** 包中的若干图形设备，我们可以将 R 的图形输出为各种格式的文件，包括位图文件（BMP、JPEG、PNG、TIFF）和矢量图文件（PDF、EPS）以及 $\TeX$ 或 $\LaTeX$ 文件。本书中除了第\@ref(cha:history)章中的历史图形以外，其它大部分图形都是使用 **tikzDevice** 包 [@tikzDevice] 中的 `tikz()` 图形设备生成的（其本质是 $\LaTeX$）。

基本的图形设备函数有位图设备 `bmp()`、`jpeg()`、`png()` 和 `tiff()`，以及矢量图设备 `svg()`、`postscript()` 和 `pdf()`。打开图形设备之后，所有的 R 图形都会在该图形设备中生成，而不会再在窗口中显示，直到图形设备关闭。下面的代码演示了图形设备的大致用法。详细信息请读者自行查阅相应的帮助文件。

```{r graphics-device,eval=FALSE, echo=TRUE}
png("my-plot.png", width = 600, height = 400) # 开启
plot(rnorm(100))
dev.off() # 关闭设备，图形被保存在文件 my-plot.png 中
pdf("another-plot.pdf", width = 7, height = 5) # PDF 图形
plot(iris)
dev.off()
```

注意：位图设备可以支持在图形中使用中文或其它 CJK 字符，但是在矢量图设备中使用中文字符时则需要设定字体族参数 `family`，否则中文不会被显示出来（例如简体中文应该用 `pdf(family = "GB1")`）。关于非标准字符在图形设备中的使用，请参考 @Murrell06 。

最后补充关于图形的一点基础知识：位图文件的图形是由一个个像素点构成的，因此放大之后会变成栅格状，不太清晰；而矢量图是由内部的数值矢量构成，这些矢量仅仅定义图形元素的始末位置以及其它属性，放大之后清晰度不变。例如一条直线在位图中由若干个点组成，而在矢量图中则是由两个点构成（给定起点和终点），图形放大之后位图的点之间可能会出现空隙，而矢量图随着放大会自动填充两点之间的空隙。为了得到高质量的打印输出，大多数情况下我们建议使用矢量图。

## 应用示例

在介绍了 R 语言的基本作图系统之后，我们应该可以理解 R 作图的自由——几乎所有图形的细节都可以被我们控制。

下面，我们举几个例子来说明如何利用图形元素来构造完整的图形。

### 瀑布图 {#subsec:waterfall-chart}

瀑布图（Waterfall Chart）的最初发明者我们无法考证，但可以在麦肯锡的报告中看到它的身影。笔者曾在某咨询公司听过一场关于 Excel 作图的培训，其中也大谈瀑布图的技巧，大致思路是用一些本来不直观的方法来完成瀑布图的制作，例如用白色填充矩形条，使之“隐藏”起来，而上面的矩形条才能得到“悬空”的效果。

瀑布图究竟是什么呢？只不过是一系列矩形而已（\@ref(sec:polygon) 小节）。它的外观类似于条形图，区别在于除了第一个矩形条之外，后面的矩形条都不再以零点为基准线来画，而是以前一个矩形条的高度为起点画矩形到该矩形条位置上的取值，这样可以反映一个变量取值的上下变化情况（主要是体现相邻矩形条的差值）。

下面，我们结合一个数据实例来说明瀑布图的简单思想和简单做法。

我们选取了 2010 年 8 月第一周“统计之都”网站的“绝对唯一访问次数”（Absolute Unique Visitors）来画瀑布图，数据如下：

```{r cos-auv-august, echo=TRUE}
# 七天之内的唯一访问次数数据（周一为 2010 年 8 月 2 日）
auv = c(939, 1005, 973, 910, 875, 658, 688)
# 相邻两天作差
diff(auv)
```

瀑布图中第一个矩形条高度为 939，第二个矩形则从 939 继续向上画 $1005-939=66$ 单位，第三个矩形则从 1005 开始向下画 32 单位，依此类推。对于访问量下滑的那些日期，可以用特殊颜色标示（比如红色警告），以区分访问量增长的日期。

图 \@ref(fig:waterfall-chart) 给出了 R 代码和瀑布图结果，其中核心代码只有最后一句，前面的代码仅以布局和美观为目的。

```{r, results='asis'}
msg_code("waterfall-chart")
```

(ref:waterfall-chart-s) “统计之都”网站 2010 年 8 月第一周访问数据瀑布图

(ref:waterfall-chart) “统计之都”网站 2010 年 8 月第一周访问数据瀑布图：周一访问量为 939， 周二上升，周三开始下降（红色矩形表示访问量下降），直到周末降到最低。这个规律在其它星期都存在，也许它反映了大众普遍的劳累和忙碌规律？

```{r waterfall-chart,fig.width=7, fig.height=5, out.width="80%", fig.scap="(ref:waterfall-chart-s)",fig.cap="(ref:waterfall-chart)"}
msg_graph("waterfall-chart")
```

从代码可以看到，我们用低层作图函数 `rect()` 来画瀑布图是非常直观的：前四个参数给定了矩形的位置坐标，而这些位置经过简单的逻辑思考很容易得到。所有任务只是画矩形而已。从这个例子可以看出 R 语言的灵活和便捷。如果使用那些缺少对图形元素充分支持的软件包，我们会付出不必要的代价。

### 梯度下降算法 {#subsec:grad-desc}

箭头在图形中的作用通常是指示。例如，图 \@ref(fig:lines-demo) 中的箭头用来将文本标注指向一条直线，这样使得文本的位置可以灵活安排。下面，我们再通过一个看起来更复杂的例子，来说明箭头的一个自然而然的应用。

很多统计计算过程都涉及迭代，因为这些计算问题没有显式解（即没有明确的数学表达式），很难一步得到答案，但可以通过迭代来一步步逼近真实解。梯度下降算法就是诸多具有迭代特征方法中的一种。梯度下降算法的目标在于寻找一个函数 $F(\mathsf{x})$ 的极值。不失一般性，我们假设寻找的是极小值。这里我们简单描述一些梯度下降算法的原理：

假设函数 $F(\mathsf{x})$ 在点 $\mathsf{a}$ 的一个小邻域内可导（这里 $\mathsf{x}$ 可以是多维向量），那么从点 $\mathsf{a}$ 出发，$F(\mathsf{x})$ 沿负梯度方向 $-\nabla F(\mathsf{a})$ 函数值下降最快。可以证明对足够小的 $\gamma>0$，若

$$\mathsf{b} = \mathsf{a}-\gamma\nabla F(\mathsf{a})$$

\noindent 那么 $F(\mathsf{a})\geq F(\mathsf{b})$。这样，我们随机猜测一个迭代的起点 $\mathsf{x}_{0}$，然后按以下方式迭代计算下一步的解 $\mathsf{x}_{n}$：

$$\mathsf{x}_{n+1} = \mathsf{x}_{n}-\gamma\nabla F(\mathsf{x}_{n}),\ n\ge0$$

\noindent 即可满足：

$$F(\mathsf{x}_{0})\ge F(\mathsf{x}_{1})\ge F(\mathsf{x}_{2})\ge\cdots$$

\noindent 这样，序列 $\left\{ \mathsf{x}_{n}\right\}$ 将收敛到局部最小值。

上述算法中，核心计算就是目标函数 $F$ 的导数（多维情况下通常称为梯度），剩下的就是简单的四则运算。求导可以用 R 自身的函数 `deriv()`，所以这个计算实现起来并不困难，而我们想要通过一个例子来说明几个在统计计算中容易被广大统计应用者忽略的问题：

1. 迭代的起点
1. 步长（本算法中可以看作是 $\gamma$）
1. 迭代次数
1. 误差

我们在实际应用中，往往过于依赖和相信计算机程序，认为所有默认设置都是最优或最可靠的，实际并非如此，否则所有的函数都没有必要设置参数了。以上四个问题是大多数迭代性质的算法都会涉及的：

- 迭代起点通常需要和真实的解相隔较近，但这个要求不具备可操作性，因为我们并不知道真实解在哪里；
- 步长通常尽量小，保证迭代能稳定收敛，否则迭代过程中跳跃很大不容易找到解，但小步长的缺点也很明显，它使得迭代进行得很慢；
- 迭代次数通常需要尽量大；
- 误差显然应该越小越好，例如在求根的问题中，我们希望目标函数值越接近于 0 越好。

图 \@ref(fig:gradArrows) 选取了一个二元函数

$$f(x,y)=\sin(x^{2}/2-y^{2}/4+3)\cos(2x+1-\exp(y)),$$

\noindent 目标是在 $\left\{ (x,y)|x\in[-1,1],\ y\in[0.5,2.2]\right\}$ 范围内求得一对 $(x,y)$，使得 $f(\cdot,\cdot)$ 最小。整幅图的背景是一幅颜色图（见 \@ref(sec:image) 小节），图中横轴表示 $x$，纵轴表示 $y$，每一对 $(x,y)$ 对应的地方有一个颜色方块，它的颜色深浅代表了函数 $f(x,y)$ 的取值大小，越深表示值越小。


(ref:gradArrows) 梯度下降算法的过程演示：对于同一个函数，我们选取 20 个迭代起点（外围大实心点），分别用不同的步长和迭代次数来进行迭代（里围相应颜色的小实心点为迭代终止位置）。从每一个起始点开始的迭代过程都由一系列箭头表示，最终这些箭头都大致指向同一个区域。本图是 2008 年笔者为中国人民大学统计学院学生刊物《统计功课》设计的封面图形，底部一行附注“一沙一世界，一花一天堂”，取自英国诗人布莱克的诗《天真的预言》，意即仔细观察统计计算过程，会看到一个我们没注意过的微观世界

(ref:gradArrows-s) 梯度下降算法的过程演示

```{r gradArrows,fig.width=6, fig.height=6,fig.scap="(ref:gradArrows-s)",fig.cap="(ref:gradArrows)",results='hide',dev='tikz',fig.process=to_png,fig.showtext=FALSE,small.mar=FALSE}
msg_graph("gradArrows")
```

(ref:sign-stat) 在统计学的轨道中（彩蛋）：本图综合运用了折线、多边形、箭头、文本和圆圈等元素，它原本是笔者于 2007 年为中国人民大学统计学院 06 级硕士班设计的一件班徽作品，但后来很多同学认为该图应重命名为“美人鱼图”。笔者初衷是将“STAT”四个字母抽象表达为一些图形元素，例如图中一系列圆圈代表“S”，两端的箭头代表“T”，中间的正态分布曲线以及阴影部分代表“A”

理想情况是，我们随意选取一个迭代起点，梯度下降算法能把我们带到图中的最深处去。这个过程在图中用一系列首尾相接的箭头表示。但是，图 \@ref(fig:gradArrows) 显示的情况并不完全与我们的预期相符：有些起始点能把我们带到低处，有些则不能；有些步长下收敛较稳定，有些步长则让迭代路径蜿蜒崎岖；有的箭头还没到最低点就停滞不前了，有些则一直能往最低的地方走。本例的目标函数也可以用 R 自身的 `optim()` 函数来求极小值，它的收敛代码为 0，表示这个计算结果在一定条件下可以收敛（但不代表找到了全局最小值，甚至不代表找到了局部最小值）：

```{r optim-f2, echo=TRUE}
f2 = function(x) sin(1 / 2 * x[1]^2 - 1 / 4 * x[2]^2 + 3) *
    cos(2 * x[1] + 1 - exp(x[2]))
# par 为局部解；value 为目标函数值； convergence 为收敛指示代码
optim(c(-.9, .9), f2, method = "L-BFGS-B", 
      lower = c(-1, .5), upper = c(1, 2.2))
```

为了叙述方便，我们将图中最高的点编号为 1，其它点按逆时针方向依次编号：

- 点 1 初始位置在“山脊”上，最初几步迭代可能使它到达了一个“陡峭”的区域（即导数值很大），所以在某一步迭代中一下跳到图的下方，然后不知所终；
- 点 3 的步长大，也有跳跃性，但迂回几次之后最终还是步入了“正轨”；
- 点 6 表现很好，但由于迭代次数很少，因此停在了在离最低点很远的地方；
- 左下角的点 7 到点 15 都表现较好，只是有些点的迭代次数不够，停在了半路；
- 右下角那个点迭代了几步就超出了搜索范围，可能前往另一个局部最小值去了；
- 最后两个点由于已经足够靠近最低点，所以步长显得太大，迭代过程左右大幅摇晃，但前进方向是对的。

图中每一个箭头所指的方向都是当前位置上的负梯度方向，理论上它与等高线是垂直的（本图没有加等高线，读者可以凭眼睛从颜色区域中简单勾勒）。显然，负梯度方向大致说来都是使得函数值下降最快的方向，因为大多数箭头都是尽快往颜色最深的地方走，这使得“梯度”的含义非常直观。另外，20 个点的表现告诉我们，有些数值计算方法在特定条件下可能并不会收敛到极大值或极小值。

笔者对流行的结构方程模型一直持保守态度，原因就是很少有人关心计算层面的东西，把一切都交给计算机去做，殊不知结构方程模型的目标函数是何等的复杂：一个普通的模型可能就包含三十个参数，这些参数是矩阵的构成元素，而目标函数又是由矩阵的逆、行列式等运算构成。也许笔者在这个问题上多虑了，但笔者所看到的模型应用者几乎无人关心迭代起始点和迭代次数，甚至有人为了防止“坏情况”发生，故意将迭代初始值或者随机数种子固定住，这样的运算毫无疑问是稳定的，但它是否可靠，还值得验证。

图 \@ref(fig:gradArrows) 同时展示了梯度下降算法的原理以及在应用中可能出现的问题（演示 `demo("gradArrows2", package = "MSG")` 可以获得更好的图形质量以及箭头动画效果），它充分显示了 R 语言的统计图形能力可以紧密结合它的统计计算优势，创造出有意义的统计图形。我们使用的只是简单的图形元素（箭头）和基本的计算（求导），但结果的深刻远大于过程的简单。从某种程度上来说，在 R 语言中作图缺的不是工具（工具俯拾皆是），而是创意、思考以及对数据的理解。

## 小结

本章对 R 基础作图系统的介绍到此为止。具备这些低层函数的知识之后，只要我们不嫌麻烦，其实所有的统计图形都可以用它们的组合使用加上一定的统计计算而一步步构建出来。当然，一般也不会有人真用这样的方法去作图（练习除外）。我们指出这一点，也是为了说明，统计图形并没有任何神秘可言；随着对图形元素的绘制以及统计量的逐渐深入了解，当一幅统计图形摆在我们面前，我们也应该能如“庖丁解牛”一般洞穿其架构。例如，从纯粹作图的意义上来讲，直方图、条形图、棘状图和马赛克图不过是矩形，条件密度图和饼图是多边形，散点图和带状图是点，折线图和向日葵散点图是线段，等等。事实上，用 R 语言的作图功能作音乐五线谱、画地图、做动画等等，都不足为奇。本书 \@ref(sec:animation) 小节中所谈到的统计学动画则是图形元素的另类应用，动画包 **animation** [@animation] 几乎完全是依靠统计计算与 R 基础图形系统而写成，例如前面提到的梯度下降算法的动画演示可以参考 **animation** 包中的 `grad.desc()` 函数。

在本书的第二部分，我们多次遇到这些基础知识的应用，读者可以留意回顾复习。图 \@ref(fig:sign-stat) 是本章最后一例“彩蛋”，供读者体会折线、多边形、箭头和文本等图形元素的用法。

(ref:sign-stat-s) 在统计学的轨道中（彩蛋）

```{r sign-stat,fig.scap="(ref:sign-stat-s)",fig.cap="(ref:sign-stat)", results='hide', dev='tikz', fig.showtext = FALSE}
msg_graph("sign-stat")
```

## 思考与练习

1. R 默认的点的样式为 `1`，即空心点。你认为这个默认设置是否合理？在数据量很小和很大的时候，你认为什么样的默认设置更好？\@ref(subsec:element-priority) 小节中详细讨论了这个问题。

2. 一幅图形的纵横比（aspect ratio）有什么作用？这个设置可能会给读者带来怎样的陷阱或假象？

3. 当我们基础图形系统时，图例的位置常常是一个麻烦问题，因为我们需要将图例放在空白的地方，避免遮挡图中其它元素。前面 \@ref(sec:legend) 小节介绍了图例函数的用法，请结合 \@ref(sec:interaction) 小节中介绍的 `locator()` 函数实现用鼠标点击的方式添加图例。

4. 在 Windows 下我们可以通过菜单点选的方式保存图形窗口中的图，这样做和用图形设备函数表面上没什么区别，但图形设备函数有两大好处：可以精确控制图形的大小，可以摆脱用户的干预。你能否构思出一些基于图形设备的程序应用？例如开发在线作图系统，用户只需要提交数据并给定一些绘图参数，服务器便可以返回相应的图片。

5. 分别用 `png()` 设备和 `jpeg()` 设备保存任意一幅图形，它们得到的图片质量和文件大小有何区别？在必须使用位图的情况下，为什么我们通常推荐使用 PNG 图形？

6. 矢量图相比起位图有什么劣势？运行以下代码并查看结果：

```{r pdf-vs-png,echo = TRUE, eval=FALSE}
x = rnorm(10000)
pdf("PDF-plot.pdf")
plot(x)
dev.off()
png("PNG-plot.png")
plot(x)
dev.off()
```

7. 彩色图形虽然在外观上很吸引人，但是它的一个局限是可能受客观条件限制而不能被打印出来（例如黑白打印机）。我们在选取颜色的时候该如何平衡外观和打印效果？另外，男性和女性的色盲 / 色弱比例各是多少[^Color_blindness]？

[^Color_blindness]: 可以查阅维基百科：<https://en.wikipedia.org/wiki/Color_blindness>

8. 图 \@ref(fig:point-iris) 在点的样式选取上是否有明显的缺陷？或者说散点图中的点应该如何选取形状以使得各组点之间的外观差异尽量大？第 \@ref(subsec:clear-symbols) 小节对这个问题有详细评论。

9. 当箭头角度参数 `angle` 为 $90\,^{\circ}$、`code` 参数为 3 时，箭头的形状是怎样的？这种形状是否和数学上的“区间”有类似之处？请考虑如何利用这种“双箭头”表达统计学中的置信区间。

10. 利用三角形的边长关系画一个指北箭头如下：

```{r north-arrow,out.width="30%", dev='tikz', fig.showtext = FALSE}
north.arrow = function(x, y, h) {
  polygon(c(x, x, x + h / 2), c(y - h, y, y - (1 + sqrt(3) / 2) *
    h), col = "black", border = NA)
  polygon(c(x, x + h / 2, x, x - h / 2), c(y - h, y - (1 + sqrt(3) / 2) *
    h, y, y - (1 + sqrt(3) / 2) * h))
  text(x, y, "N", adj = c(0.5, 0), cex = 4)
}
par(mar = rep(0, 4))
plot(1,
  type = "n", ylim = c(0, 1), axes = FALSE,
  ann = FALSE
)
north.arrow(1, 0.8, 0.4)
```

11. 一些数学函数可以产生有趣的“心形曲线”，例如在极坐标系下 $r(\theta)=1-\sin(\theta)$ 生成的就是心形的曲线，笛卡尔坐标下方程 $(x^{2}+y^{2}-1)^{3}-x^{2}y^{3}=0$ 对应的解也可以形成心形曲线。这里我们考虑一种简单的心形曲线如下图所示。这是个左右对称的形状，因此只需要知道左右任一侧的画法就知道整体画法了。实际上，右侧由上下两部分构成，上面是直径为 1 的半圆，下面是翻转了 $90\,^{\circ}$ 的曲线 $y=\sin(x), x\in[0,\pi/2]$。请思考如何用多边形构造这个形状。MSG 包中的函数 `heart_curve()` 可供参考。

```{r heart-curve,out.width="30%",fig.asp=1, dev='tikz', fig.showtext = FALSE}
MSG::heart_curve(col = "red")
abline(v = 0, h = pi / 2, lty = 2, col = "gray")
```

12. 温度计形状用来表达比例数据通常很形象，我们可以设定温度计的范围在 $[0,\,1]$ 之间，用汞柱的高度来表达比例。用 R 构造一支“温度计”很简单，如下图：这些温度计实际上由一个灰圆点、一个红圆点、一条灰线段和一条红线段叠加构成，红线段的长度表示比例大小，其它图形元素都只是背景。请尝试用四个图形元素构造温度计，注意这些图形元素的叠加顺序（例如红线必须在灰线之后画，否则会被覆盖）。\@ref(sec:symbols) 小节的符号图中，“符号”的选项之一就是用温度计，但不如这里的温度计形象。对于追求细节完美的用户来说，这里线段末端的样式也值得注意，因为我们实际生活中看到的汞柱末端是弧形的，所以这里要是画成矩形就不合适了；线段末端的三种样式在 \@ref(sec:par) 小节中有介绍。

```{r thermometer-demo,fig.width=4,fig.height=1.5,out.width="75%",echo=FALSE, dev='tikz',fig.showtext=FALSE}
par(mar = rep(0.5, 4))
plot.new()
for (i in c(.2, .5, .8)) {
  segments(0.1, i, 1, i, lwd = 20, col = "gray")
  points(.1, i, cex = 5, pch = 19, col = "gray")
  segments(0.1, i, 1 - i, i, lwd = 10, col = "red")
  points(.1, i, cex = 3, pch = 19, col = "red")
}
text(0.02, c(.2, .5, .8), LETTERS[1:3])
```
